09. ADVANCED DOM AND EVENTS        
        - Building a tabbed component
        - Passing arguments to event handlers
        - Implementing a sticky navigation: the scroll event

___________________________________________________________________________________________________________________________________
09. ADVANCED DOM AND EVENTS






/////////////////////////////////
// Building a tabbed component //
/////////////////////////////////

// selecting elements to work with tabs
const tabsContainer = document.querySelector(`.operations__tab-container`);
const tabsBtns = document.querySelectorAll(`.operations__tab`);
const tabsContents = document.querySelectorAll(`.operations__content`);

// using event delegation, so add event listener on container
tabsContainer.addEventListener(`click`, function (event) {
  // preventing default just to be sure (not really necessary)
  event.preventDefault();

  // get the element (during bubbling) which provocated event --> event.target
  // and find the actual button because there is the <span> inside --> .closest(`.operations__tab`);
  const clickedBtn = event.target.closest(`.operations__tab`);

  // if `clickedBtn` is null so there was a click on container and not button then just exit function
  if (!clickedBtn) return;

  // otherwise get the `data-tab` attribute to understand which content should be shown
  const numberContent = clickedBtn.dataset.tab;

  // remove active class from all tab buttons
  // and add active class only on clicked tab button
  tabsBtns.forEach(el => el.classList.remove(`operations__tab--active`));
  clickedBtn.classList.add(`operations__tab--active`);

  // remove active class from all <div>s with content to show
  // and add active class only to <div> with correct numberContent class
  tabsContents.forEach(el =>
    el.classList.remove(`operations__content--active`)
  );
  document
    .querySelector(`.operations__content--${numberContent}`)
    .classList.add(`operations__content--active`);
});







/////////////////////////////////////////
// Passing arguments to event handlers //
/////////////////////////////////////////


// NOTE:
//  `mouseover` and `mouseout` do bubbling
//  `mouseenter` and `mouseleave` don't do bubbling


const changeOpacityNav = function (event, opacity) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = opacity;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = opacity;
  }
};

const navBar = document.querySelector(`.nav`);

navBar.addEventListener(`mouseover`, function (event) {
  changeOpacityNav(event, 0.5);
});

navBar.addEventListener(`mouseout`, function (event) {
  changeOpacityNav(event, 1);
});




//// --------------- BEST SOLUTION --------------- ////




// The best way to pass argument into an event handlers' callback function
// is to use bind method, set the `this` keyword and pass `this` as variable inside the callback body
// any event handler function can have only 1 real argument, which is the `event`
// if you want to pass more arguments set `this` in bind to an array or object

const navBar = document.querySelector(`.nav`);

const changeOpacityNav = function (event) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = this;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = this;
  }
};

navBar.addEventListener(`mouseover`, changeOpacityNav.bind(0.5));
navBar.addEventListener(`mouseout`, changeOpacityNav.bind(1));







////////////////////////////////////////////////////////
// Implementing a sticky navigation: the scroll event //
////////////////////////////////////////////////////////



//// -------------- OLD BAD SOLUTION -------------- ////



// REMEMBER:
// const navBar = document.querySelector(`.nav`);
// const section1 = document.getElementById(`section--1`);

// calculate the coordinates of section1
const seciton1Coordinates = section1.getBoundingClientRect();

window.addEventListener(`scroll`, function () {
  if (window.scrollY > seciton1Coordinates.top) {
    navBar.classList.add(`sticky`);
  } else {
    navBar.classList.remove(`sticky`);
  }
});







///////////////////////////////////
// The intersection Observer API //
///////////////////////////////////

