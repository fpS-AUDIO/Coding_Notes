

(!)     ENGLISH LANGUAGE VERSION



///////////////////////////
//// JAVASCRIPT COURSE ////
///////////////////////////




00. JAVASCRIPT FUNDAMENTALS (part 1)
        - definition
        - variables
        - operators
        - template strings
        - if else
        - conversation and coerecion
        - Truthy and Falsy Values
        - The Switch Statement        
        - Statements and Expressions
        - Conditional (ternary) operator

01. JAVASCRIPT FUNDAMENTALS (part 2)
        - Activating strict mode
        - Functions
        - Functions Declaration vs expression
        - Arrow Functions
        - Functions calling other functions
        - Arrays
        - JavaScript Array Methods and Propertie
        - Objects
        - Objects methods
        - Objects built in methods
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 





___________________________________________________________________________________________________________________________________
00. JAVASCRIPT FUNDAMENTALS (part 1)



JavaScript is a hight level, objet oriented, multi-paradigm programming language.
    programming language    ->  instructions for computer
    hight level             ->  easier language (no memory management)
    objet oriented          ->  based on objects to store data
    multi-paradigm          ->  allows to use different styles of programming (imperative and declerative programming)

3 core languages of web development:
    1.  HTML            (nouns)
    2.  CSS             (adjectives)
    3.  JAVASCRIPT      (verbs)

JS has multimple updates. One of the the biggest in last years was in 2015.
The update is ES6/ES2015    ->  E.S. = ECMAScript
In 2023 the "modern JS" means all updates after 2015.


JS code can be:
    -   putted inline script in hetml tag       <script>...</script>
    -   linked in a separate file               <script src="script.js" defer></script>
                                                defer ->    load in the ened on file (only external files)





Just random basics
----------------------------------------------------------
;                                       let JS know the instruction is finished (good practice)

console.log();                          show staff on console

alert("Hello world")                    make and alert

// this is a comment

/* this is a multiline comment */

\n                                      new line

\t                                      tab

\                                       escaping character ex: "\"hello\" world"

clear()                                 clear console in browser

prompt("Enter something")               get promt windows (it's like an input from alert)
                                            ex: let age = promt("Enter your age: ")



----------------------------------------------------------





///////////////
// variables //
///////////////

we can store a value in variables
(value = piece of data)



var firstName = "Jonas";
    var is legacy (old) way of declaring variables.
    it works as "let"


let firstName = "Jonas";    
    let is used to mutate (reassign) the variable subsequently
    We can declare empty variables.

    EXAMPLE:
    let birthYear = 1996;
    birthYear = 1997;


const firstName = "Jonas";
    const is used for variables which are not supposed to change
    so const is used for immutable variables.
    We can't declare empty variables.

    EXAMPLE:
    const birthYear = 1996;
    birthYear = 1997;
    // TypeError



The way of calling variable is called camelCase.
    camelCase means 1st word is lowercase and other word starts with uppercase 
    and all the words are connected. camelCase is standard in JS.

Variables:
    - can't start with a number like "3years"
    - can contain only letters, numbers, _, $
    - can't be the same as a reserved keywords like "new"
    - better don't use "name" 
    - all in uppercase means it's a constant like:  let PI = 3.1415;

Every value is an object or a primitive value.
primitive value:
let firstName = "Jonas";

object:
let me = {
    name: "Jonas";
}


primitive data types:
    - numbers
        floating point numbers used for decimals and integers
        23, 23.1

    - strings
        sequence of character put inside the ""
        "Hello World"

    - boolean
        true or false

    - undefined
        value is taken by a variable that is not yet defined (empty value)  
        let children;

    - null
        empty value

    - symbol
        (ES2015) value is unique and can't ba changed

    - bigInt
        larger integers than the numbers type can hold


(!) JS has dynamic typing
    We don't need manually define the data type of a value stored in a variable,
    the data types are determined automatically.
    Also the variables can be reassigned with different values.


typeof  ->  operator which shows the data type of a variable
    EXAMPLE:
    console.log(typeof true);
    // boolean

There is a weird bug in JS.
When we run:
    console.log(typeof null);
    // object   -> but it's not an object



(!) We need to use "let" when we create a variable,
    but we don't need to use it to change the value of a variable.

    EXAMPLE:
    let JavaScriptIsFun = true;
    JavaScriptIsFun = "YES!";





///////////////
// operators //
///////////////

operators = allows us to transform values or combine multiple values.

    1.  mathematical operators
        (+  -   *   /   **)


    2.  assignment operators
        (=  +=  -=  *=  /=  ++  --)


    3.  comparison operators
        (>  <   >=  <=)


    4.  equality operators
        (== ===)

        "2" == 2 (loose equality operator)        
            // true       ->     do type coercion
            // which basically means it's trying its best to convert 
            // both of the objects to similar data types to actually perform the comparison.
            // !=

        "2" === 2 (strict equality operator)        
            // false      ->     DO NOT type coercion
            // comparison based on data type space
            // !==


    5.  boolean logic operators

        AND
        >>>1 === 1 && 2 === 2
            // && = and

        OR
        >>>1 === 1 || 2 === 2
            //  || = or

        NOT
        >>>!(1===1)
            // ! = not 





//////////////////////
// template strings //
//////////////////////

// data for examples below
const firstName = "John";
let ageJohn = 39;
let currentYear = 2023;


Concatenation:
    console.log("Hello, my name is " + firstName + " and I'm " + ageJohn + " years old");

    console.log("String with \n\
    multiple \n\
    lines");


Template strings (uses ``):
    console.log(`Hello, my name is ${firstName} and I'm ${ageJohn} years old`);
    console.log(`${currentYear - ageJohn}`);

    console.log(`String with
    multiple
    lines`);





/////////////
// if else //   ->  official name: Control Structure
/////////////


IF STATEMENT
if (condition 1){
       // execute some code;
}else if (condition 2){
       // execute some other code;
}else if (condition 3){
       // execute some other code;
...
}else{
       // execute some backup code;
}


EXAMPLE:

    // data for example below
    const age = 16;
    const isOldEnaugh = age >= 18;

    if (isOldEnaugh) {
        console.log(`Can start driving`);
    } else {
        const yearLeft = 18 - age;
        console.log(`You're too young, and you can drive in ${yearLeft} years.`)
    }





////////////////////////////////
// conversation and coerecion //
////////////////////////////////

type conversion ->  we manually convert from one type to another
type coerecion  ->  when JavaScript automatically converts types


Number()    ->  function is used to convert a value to a number. ...
String()    ->  function is used to convert a value to a string. ...
Boolean()   ->  function is used to convert a value to a boolean. ...
Null()      ->  function is used to convert a value to null.

(!) These functions don't convert original value
    they just return a new value

EXAMPLE:
    const inputYear = `1991`;
    const inputYearNumber = Number(inputYear);





/////////////////////////////
// Truthy and Falsy Values //
/////////////////////////////

5 falsy values if we convert them in boolean:
    1.  0
    2.  `` (empty string)
    3.  undefined
    4.  null
    5.  NaN (not a number)





//////////////////////////
// The Switch Statement //
//////////////////////////

Switch Statement
    is an alternative way of writing a if/else statement, when all we want 
    to do is to compare one value to multiple different options.


EXAMPLE:
const day = `monday`;

switch(day) {                               // we are comparing `day`
    case `monday`:                          // to `Monday` in a strict equality way
        console.log(`plan studying`);       // so if day === `monday` the code below will be executed
        console.log(`go coding`);
        break;                              // without the break the code continues executing and it stops when it find a break
    case `tuesday`:
        console.log(`prepare video`);
        break;
    case `wednesday`:                       // run the same code for two different values
    case `thursday`:                        // to do that we need to specidy two cases in a row
        console.log(`do sport`);
        break;
    case `saturday`:
    case `sunday`:
        console.log(`engoy weekend`);
        break;
    default:                                // default will be executed only if all the other cases fail
        console.log(`not a valid day`);
}   





////////////////////////////////
// Statements and Expressions //
////////////////////////////////


expression
    is a piece of code that produces a value.
    EXAMPLE: 3 + 4
    EXAMPLE: 1991
    EXAMPLE: true && !false


statement
    is like a bigger piece of code that is executed
    and which does not produce a value on itself
    EXAMPLE:
    if (18>10) {
        const str = `18 is bigger`;
    }
 




////////////////////////////////////
// Conditional (ternary) operator //
//////////////////////////////////// 

conditional operator
    allows to to write something similar to an if/else statement
    but just in one line


syntax:
    condition ? code-if-condition-is-true : code-if-condition-is-false(else);


EXAMPLE #1:
    const age = 16;
    age >= 18 ? console.log(`I like drink wine`) : console.log(`I like drink water`);
    // output   ->  I like drink water


EXAMPLE #2:
    const drink = age >= 18 ? `wine` : `water`;



(!) since the ternary operator, is a expression it produces a value,
    so we can insert it inside of a template literal which accepts only expressions.

    EXAMPLE:
    console.log(`I like to drink ${age >= 18 ? `wine` : `water`}`);
    // output   ->  I like to drink water
 





___________________________________________________________________________________________________________________________________
01. JAVASCRIPT FUNDAMENTALS (part 2)





////////////////////////////
// Activating strict mode //
////////////////////////////

strict mode
    is a special mode that we can activate in JavaScript, which makes it easier 
    for us to write a secure JavaScript code.

(!) To activate the strict mode in JS we need to write in the very first line (1st statement):
    'use strict';

(!) We should always use the strict mode


Secure means that strict mode makes it easier for developers to avoid accidental errors.
It helps us introduce the bugs into our code.
strict mode:
    1.  forbids us to do certain things
    2.  it will actually create visible errors for us
        (when JS would just fail silently)
    3.  introduces a short list of variable names that are reserved for features
        that might be added to the language a bit later (EXAMPLE: let interface)





///////////////
// Functions //
///////////////


functions
    piece of code that we can reuse over and over again in our code
--------------------------------------------
syntax:     (function declaration)
--------------------------------------------
function functionName() {
    // function body
    console.log(`execute this code when we call func`);             
}

// calling / runing / invoking function
functionName()                                                      





--------------------------------------------
input data:     (function declaration)
--------------------------------------------

function fruitProcessor(apples, oranges) {  
    // apples, oranges -> input data of a function
    const juice = `Juice with ${apples} apples and ${oranges} oranges`
    // return keyword   ->  we can return any value from the function
    return juice;
}

const appleJuice = fruitProcessor(4, 0);
console.log(appleJuice);
console.log(fruitProcessor(4, 0));
// Juice with 4 apples and 0 oranges

(!) return will exits immediately from a function



/////////////////////////////////////////
// Functions Declaration vs expression //
/////////////////////////////////////////


In JavaScript, there are different ways of writing functions.

(!) In examples above we can see function declarations, 
    because we simply use the function keyword.





--------------------------------------------
function declaration:
--------------------------------------------

function calculateAge1(birthYear) {
    return 2023 - birthYear;
}

const age1 = calculateAge1(1996);





--------------------------------------------
function expression:
--------------------------------------------

const calculateAge2 = function (birthYear) {
    return 2023 - birthYear;
}

const age2 = calculateAge2(1996);

(!) function expression is a function without a name (also called an anonymous function),
    and it's an expression and remember that an expression produces a value.
    So we use that value to store it into calcAge2 variable.



(!) the main practical difference between function declarations and function expressions
    is that we can call function declarations before they are defined in the code.
    This is happening because of the process called hoisting.
    (this doesn't work with the expression)

    so we can write this:

    // calling function
    const age1 = calculateAge1(1996);

    // defining function
    function calculateAge1(birthYear) {
    return 2023 - birthYear;
    }





//////////////////////
// Arrow Functions  //
//////////////////////
    
Arrow Functions are added to JavaScript in ES6.
Arrow Functions is a special form of function expression
that is shorter and faster to write.



--------------------------------------------
SYNTAX:
    variable = parameter => write what need to return;


EXAMPLE #1:
const calculateAge3 = birthYear => 2023 - birthYear;
const age3 = calculateAge3(1996);



--------------------------------------------
(!) we still need to use {} and return if we need to define a code block
    (have more lines of code)


EXAMPLE #2:
const yearsUntileRetirement = birthYear => {
    const age = 2023 - birthYear;
    const retirement = 65 - age;
    return retirement;
}
const retirementYears = yearsUntileRetirement(1996);



--------------------------------------------
(!) we need to wrap parameter inside parentheses ()
    if we have more then 1 parameter.


EXAMPLE #3:
const yearsUntileRetirement = (birthYear, firstName) => {
    const age = 2023 - birthYear;
    const retirement = 65 - age;
    return `${firstName} retires in ${retirement} years`;
}
const retirementYears = yearsUntileRetirement(1996, `Alex`);
console.log(retirementYears);

// or we can just write
// console.log(yearsUntileRetirement(1996, `Alex`));



--------------------------------------------
(!) There is a difference between the arrow function and 
    traditional functions (function declarations and function expressions).
    arrow functions don't have `this` keyword





///////////////////////////////////////
// Functions calling other functions //
///////////////////////////////////////

function cutFruitInPieces(fruit) {
    return fruit * 4;
}

function fruitProcessor(apples, oranges) {  
    const applePieces = cutFruitInPieces(apples);
    const OrangePieces = cutFruitInPieces(oranges);

    const juice = `Juice with ${applePieces} pieces of apples and ${OrangePieces} pieces of oranges`
    return juice;
}





////////////
// Arrays //
////////////


Arrays 
    Arrays are a data structure like a big container into which 
    we can throw variables and then later reference them.

    Array is not a primitive value so it's mutable even if we use `conts` to declare it

    (!) but we can't replace an array
        so we CAN'T do this:
        const friends = [`Michael`, `Steven`, `Peter`];
        friends = [`Mattia`, `Paolo`];                      // TypeError

    Inside an array we can put variables, different data types and other arrays



--------------------------------------------
const friends = [`Michael`, `Steven`, `Peter`];
const years = new Array(1996, 1994, 2001);

(!) instead of [] we can use `new Array()` 
    new         keyword
    Array()     function


console.log(friends[0]);                            // 1st element
console.log(friends.length);                        // array length
console.log(friends[friends.length - 1]);           // last element

(!) inside the [] we can put an expression (produces a value).

friends[2] = "Sasha"                                // change the value in that index





////////////////////////////////////////////
// JavaScript Array Methods and Propertie //
////////////////////////////////////////////

array.method(parameter);


at()	            Returns an indexed element of an array
concat()	        Joins arrays and returns an array with the joined arrays
constructor	        Returns the function that created the Array object's prototype
copyWithin()	    Copies array elements within the array, to and from specified positions
entries()	        Returns a key/value pair Array Iteration Object
every()	            Checks if every element in an array pass a test
fill()	            Fill the elements in an array with a static value
filter()	        Creates a new array with every element in an array that pass a test
find()	            Returns the value of the first element in an array that pass a test
findIndex()	        Returns the index of the first element in an array that pass a test
flat()	            Concatenates sub-array elements 
flatMap()	        Maps all array elements and creates a new flat array
forEach()	        Calls a function for each array element
from()	            Creates an array from an object
includes()	        Check if an array contains the specified element (returns true or false)
indexOf()	        Search the array for an element and returns its position (index)
isArray()	        Checks whether an object is an array
join()	            Joins all elements of an array into a string
keys()	            Returns a Array Iteration Object, containing the keys of the original array
lastIndexOf()	    Search the array for an element, starting at the end, and returns its position
length	            Sets or returns the number of elements in an array
map()	            Creates a new array with the result of calling a function for each array element
pop()	            Removes the last element of an array, and returns that element
prototype	        Allows you to add properties and methods to an Array object
push()	            Adds new elements to the end of an array, and returns the new length
reduce()	        Reduce the values of an array to a single value (going left-to-right)
reduceRight()	    Reduce the values of an array to a single value (going right-to-left)
reverse()	        Reverses the order of the elements in an array
shift()	            Removes the first element of an array, and returns that element
slice()	            Selects a part of an array, and returns the new array
some()	            Checks if any of the elements in an array pass a test
sort()	            Sorts the elements of an array
splice()	        Adds/Removes elements from an array
toString()	        Converts an array to a string, and returns the result
unshift()	        Adds new elements to the beginning of an array, and returns the new length
valueOf()	        Returns the primitive value of an array


example:            let boolResult = friends.includes(`Steven`);

--------------------------------------------





/////////////
// Objects //
/////////////


Object
    In Objects we define key:value pairs like dictionaries in python.
    Objects can hold different types of data.
    Every key:value pair is 1 property.
    Object()    Turns the input into an object.


SYNTAX:
variable = {
    key: value;
}



EXAMPLE:
const john = {
    firstName: `John`,                          // property 1
    lastName: `Wick`,                           // property 2 ...
    age: 2023 - 1996,                           
    job: `hacker`,
    friends: [`Bander`, `Lila`, `Mattia`]
}



// get property
console.log(john.lastName);
console.log(john[`lastName`]); 

// add property
john.location = `China`;
john[`location`] = `China`;


(!) inside [] we can put any expression
    EXAMPLE:
    const nameKey = `Name`;
    console.log(john[`last` + nameKey]); 
    console.log(john[`first` + nameKey]); 





/////////////////////
// Objects methods //
/////////////////////

Any function that is attached to an object is called a method.

(!) if functions are another type of value means that we can 
    create a key value pair in which the value is a function,
    so we can add functions inside an object.
    
    That works because the expression produces the value,
    and function declaration will NOT work.



const john = {

    firstName: `John`,                                      // string value
    lastName: `Wick`,                           
    birthYear: 1996,                           
    job: `hacker`,
    friends: [`Bander`, `Lila`, `Mattia`],                  // array value
    hasDriverLicense: true,                                 // boolean value



    // key(name-of-function): function-expression
    calcAge: function (birthYear) {                         // function value
        return 2023 - birthYear;
    },



    // using `this`
    calcAge2: function () {
        return 2023 - this.birthYear;
    },



    // most efficient solution
    calcAge3: function () {

        // creating a new property with this.age
        this.age = 2023 - this.birthYear;    
        return this.age;
    }
}


(!) `this` keyword is basically equal to the object on which the method is called
    (it is equal to the object calling the method)



// access to function property
john.calcAge(1996);
john[`calcAge`](1996);


// access to function property using `this`
john.calcAge2();


// calling the func property creating the new property and 
// then acceess directly to the new property
john.calcAge3();
john.age





//////////////////////////////
// Objects built in methods //
//////////////////////////////


Object.assign()
        Copies the values of all enumerable own properties from one or 
        more source objects to a target object.

Object.create()
        Creates a new object with the specified prototype object and properties.

Object.defineProperties()
        Adds the named properties described by the given descriptors to an object.

Object.defineProperty()
        Adds the named property described by a given descriptor to an object.

Object.entries()
        Returns an array containing all of the [key, value] pairs of a 
        given object's own enumerable string properties.

Object.freeze()
        Freezes an object. Other code cannot delete or change its properties.

Object.fromEntries()
        Returns a new object from an iterable of [key, value] pairs. 
        (This is the reverse of Object.entries).

Object.getOwnPropertyDescriptor()
        Returns a property descriptor for a named property on an object.

Object.getOwnPropertyDescriptors()
        Returns an object containing all own property descriptors for an object.

Object.getOwnPropertyNames()
        Returns an array containing the names of all of the given object's
        own enumerable and non-enumerable properties.

Object.getOwnPropertySymbols()
        Returns an array of all symbol properties found directly upon a given object.

Object.getPrototypeOf()
        Returns the prototype (internal [[Prototype]] property) of the specified object.

Object.groupBy() Experimental
        Groups the elements of a given iterable according to the string values 
        returned by a provided callback function. The returned object has separate 
        properties for each group, containing arrays with the elements in the group.

Object.hasOwn()
        Returns true if the specified object has the indicated property as its
        own property, or false if the property is inherited or does not exist.

Object.is()
        Compares if two values are the same value. Equates all NaN values 
        (which differs from both IsLooselyEqual used by == and IsStrictlyEqual used by ===).

Object.isExtensible()
        Determines if extending of an object is allowed.

Object.isFrozen()
        Determines if an object was frozen.

Object.isSealed()
        Determines if an object is sealed.

Object.keys()
        Returns an array containing the names of all of the given 
        object's own enumerable string properties.

Object.preventExtensions()
        Prevents any extensions of an object.

Object.seal()
        Prevents other code from deleting properties of an object.

Object.setPrototypeOf()
        Sets the object's prototype (its internal [[Prototype]] property).

Object.values()
        Returns an array containing the values that correspond to all of a 
        given object's own enumerable string properties.



--------------------------------------------
Instance properties

(!) These properties are defined on Object.prototype and shared by all Object instances.

(OLD) Object.prototype.__proto__
        Points to the object which was used as prototype when the object was instantiated.

Object.prototype.constructor
        The constructor function that created the instance object. 
        For plain Object instances, the initial value is the Object constructor. 
        Instances of other constructors each inherit the constructor property 
        from their respective Constructor.prototype object.


--------------------------------------------
Instance methods


(OLD) Object.prototype.__defineGetter__()
        Associates a function with a property that, when accessed, 
        executes that function and returns its return value.

(OLD) Object.prototype.__defineSetter__()
        Associates a function with a property that, when set, 
        executes that function which modifies the property.

(OLD) Object.prototype.__lookupGetter__()
        Returns the function bound as a getter to the specified property.

(OLD) Object.prototype.__lookupSetter__()
        Returns the function bound as a setter to the specified property.

Object.prototype.hasOwnProperty()
        Returns a boolean indicating whether an object contains the 
        specified property as a direct property of that object and not 
        inherited through the prototype chain.

Object.prototype.isPrototypeOf()
        Returns a boolean indicating whether the object this method 
        is called upon is in the prototype chain of the specified object.

Object.prototype.propertyIsEnumerable()
        Returns a boolean indicating whether the specified property is 
        the object's enumerable own property.

Object.prototype.toLocaleString()
        Calls toString().

Object.prototype.toString()
        Returns a string representation of the object.

Object.prototype.valueOf()
        Returns the primitive value of the specified object.



