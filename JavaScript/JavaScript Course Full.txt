09. ADVANCED DOM AND EVENTS
        - How the DOM really works 
        - Selecting, creating and deleting elements
        - Styles, attributes and classes
        - Implementing Smooth scrolling 
        - Types of events and event handlers
        - Event propagation: bubbling and capturing
        - Event propagation: practice 
        - Event delegation: implementing page navigation         
        - DOM traversing
        - Building a tabbed component
        - Passing arguments to event handlers
        - Implementing a sticky navigation: the scroll event

___________________________________________________________________________________________________________________________________
09. ADVANCED DOM AND EVENTS




///////////////////////////////////////////////
// Selecting, creating and deleting elements //
///////////////////////////////////////////////



// ------------------- SELECTING ELEMENTS ------------------- //



// selecting the entire document, head and body:

console.log(document.documentElement);
console.log(document.head);
console.log(document.body);

// :root === document.documentElement



// other methods of selecting:

document.querySelector(`.header`); // returns the 1st element which matches the selector
document.querySelectorAll(`.section`); // returns NodeList with all elements which matches the selector
document.getElementById(`section--1`); // returns the element which matches the id
document.getElementsByTagName(`buttons`); // returns an life HTML collection with all HTML elements with type of `buttons` in this case
document.getElementsByClassName(`btn`); // return a life html collection with all elements with class of `btn`

// NOTE: `HTML collection` is a `life-collection" which means they automatically updated when DOM changes
// NOTE: `NodeList` are not automatically updated



// ------------------- CREATING ELEMENTS ------------------- //



// 1. insertAdjacentHTML

// container.insertAdjacentHTML(`afterbegin`, htmlPiece);

// You can create a variable containing the template literal string with HTML.
// Then you can simply "inject" this template literal inside the HTML.

// htmlElement.insertAdjacentHTML(`place`, htmlString);
//  where `place` can be:
//      - "beforebegin"     -> before the html element if it has parent
//      - "afterbegin"      -> inside the html element before the 1st child
//      - "beforeend"       -> inside the html element after the last child
//      - "afterend"        -> after the html element if it has parent


// -------------- //


// 2. document.createElement(HtmlTagNameStr);

const message = document.createElement(`div`);

// this method also returns A DOM element
// this element is not yet in DOM but it's stored in a variable and you can do operations on it
// (the element retur is of the same type like element returned from document.querySelector(`.header`); )
message.classList.add(`cookie-message`);
message.textContent = `We're using cookies to improve functionality`;
message.innerHTML = `We're using cookies to improve functionality <button class="btn btn--close-cookie">Got it!</button>`;


// -------------- //


// 3. prepend() append() -> actually adding this elemento to the HTML

container.prepend(message); // add message as the first child of the container
container.append(message); // add message as the last child of the container

// now this message is life element of the DOM (it CAN'T be in different places in the document)
// so in the example above it was positioned as 1st child, then moved as last child
// so you can use prepand and append to move elements


// -------------- //


// 4. cloneNode() -> copy element

container.append(message.cloneNode(true)); // add message as the last child of the container
// if argument is `true` also the child elements will be copied


// -------------- //


// 5. before() after()

// before() insert element before HTML element (not as child)
// after() insert element after HTML element (not as child)
container.before(message);



// ------------------- DELETING ELEMENTS ------------------- //



// 1. remove() -> removes element from HTML (recent element)
message.remove();

// 2. elementXX.parentElement.removeChild(elementXX); (legacy)
// before we needed to select the parent element and then remove the children
message.parentElement.removeChild(message);





  // ----------------------------------------- //
EXAMPLE OF CREATING, ADDING AND REMOVING A COOKIE DIV:
  // ----------------------------------------- //


const header = document.querySelector(`.header`);

const cookieMessageDiv = document.createElement(`div`);
cookieMessageDiv.classList.add(`cookie-message`);
cookieMessageDiv.innerHTML = `I know cookies are so sad, but we're using them to improve functionality <button class="btn btn--close-cookie">Got it!</button>`;
header.before(cookieMessageDiv);

// selecting AFTER creating
const btnCloseCookie = document.querySelector(`.btn--close-cookie`);

// EventListener close Cookies Div
btnCloseCookie.addEventListener(`click`, function () {
  cookieMessageDiv.remove();
});






////////////////////////////////////
// Styles, attributes and classes //
////////////////////////////////////



// ------------------- STYLES ------------------- //


//    element.style.camelCaseStyle = `value`
// change style property
// doing this way the styles will be places `inline`
cookieMessageDiv.style.backgroundColor = `#37383d`;
cookieMessageDiv.style.width = `120%`;


//    element.style.camelCaseStyle
// read style property ONLY set inline
console.log(cookieMessageDiv.style.width); // 120%
console.log(cookieMessageDiv.style.height); // NOTHING BECAUSE IS NOT INLINE STYLE


//    getComputedStyle(element).camelCaseStyle
// get the real style as it appears on the page (even if it's not declared)
console.log(getComputedStyle(cookieMessageDiv)); // A REALLY BIG LIST OF STYLES
console.log(getComputedStyle(cookieMessageDiv).height); // 75px


//    document.documentElement.style.setProperty(`nameOfProperty`, `newValue`)
// css variables === (css custom properties)
// change the value of a css variable
document.documentElement.style.setProperty(`--color-primary`, `#52a064`);



// EXAMPLE:
cookieMessageDiv.style.height =
  Number.parseFloat(getComputedStyle(cookieMessageDiv).height) + 30 + `px`;




// ------------------- ATTRIBUTES ------------------- //


// attributes are: src, alt, id, href, placeholder etc...
// every type of element has its own standard attributes


//    element.standardAttributeName
// get or set the value of the standard attributes
console.log(logoIMG.src); // http://127.0.0.1:5500/img/logo.png (ABSOLUTE URL)
console.log(logoIMG.alt); // Bankist logo
console.log(logoIMG.className); // nav__logo (it's className and not simply class)

logoIMG.alt = `Cool Bankist App Logo`;
console.log(logoIMG.alt); // Cool Bankist App Logo


//    element.getAttribute(`attributeName`)
// get the value of the NON standard attributes (also works with standrd)
// this method gives you RELATIVE attibutes and not ABSOLUTE (of src, href...)
console.log(logoIMG.designer); // undefined (BECAUSE IT'S NOT STANDARD PROPERTY)
console.log(logoIMG.getAttribute(`designer`)); // Jonas
console.log(logoIMG.getAttribute(`src`)); // img/logo.png


//    element.setAttribute(`attributeName`, `newValue`)
// set the value of the NON standard attributes
logoIMG.setAttribute(`designer`, `Jonas New Attribute`);
console.log(logoIMG.getAttribute(`designer`)); // Jonas New Attribute


//    element.dataset.dataAttributeName = `newValue`
// get or set data attribute from `dataSet` object
// NOTE:  there is a special type of attributes called `data attributes`
//        data attributes always starts with `data-`
//        we need to transform the name in camelcase without 1st word `data` like below
//        example: data-version-number-actual="3.0"   --> versionNumberActual
console.log(logoIMG.dataset.versionNumberActual); // 3.0




// ------------------- CLASSES ------------------- //

// element.classList.add(`className`)
// element.classList.remove(`className`)
// element.classList.toggle(`className`)
// element.classList.contains(`className`)

// this OVVERERIDE all classes (bad practice)
// element.className = `className`






///////////////////////////////////
// Implementing Smooth scrolling //
///////////////////////////////////

---------------------------------------------------------------------------------

//    element.getBoundingClientRect();
// returns `DOMRect object` which is the smallest rectangle which contains the entire element
// this object describes the position and size of the overall rectangle in pixels
// Properties (NOT width and height) are relative to the top-left of the viewport.

EXAMPLE of DOMRect object:
  bottom: 3657.1875
  height: 2384.1875
  left: 0
  right: 641
  top: 1273
  width: 641
  x: 0                -> px from left of viewport
  y: 1273             -> px from top of viewport


---------------------------------------------------------------------------------

//    window.scroll(x, y)    /    window.scroll(optionsObject)
// scroll windows to coordinates of x and y (in pixels)
// scrollTo() is the same method

options = {
  top: 100,
  left: 100,
  behavior: "smooth" / "instant" / "auto",
}


console.log(window.scrollX); // returns px of scrolling from LEFT
console.log(window.scrollY); // returns px of scrolling from TOP


---------------------------------------------------------------------------------

//    calculate viewport size
document.documentElement.clientHeight; // returns px of the viewport height
document.documentElement.clientWidth; // returns px of the viewport width

---------------------------------------------------------------------------------


// PRACTICAL EXAMPLE:

// selecting elements
const btnScrollTo = document.querySelector(`.btn--scroll-to`);
const section1 = document.getElementById(`section--1`);



btnScrollTo.addEventListener(`click`, function (event) {
  // get the coordinates of seciton1
  const seciton1Coordinates = section1.getBoundingClientRect();

  // to get the correct coordinates you need to sum:
  //  1. px from top of viewport
  //  2. current scroll position
  // like this:
  const sect1X = seciton1Coordinates.x + window.scrollX;
  const sect1Y = seciton1Coordinates.y + window.scrollY;

  // creating the object with options for scroll()
  const scrollOptions = {
    top: sect1Y,
    left: sect1X,
    behavior: `smooth`,
  };

  // scroll to the correct position
  window.scroll(scrollOptions);
});


---------------------------------------------------------------------------------
// MODERN WAY:
// element.scrollIntoView({behavior: `smooth`});
section1.scrollIntoView({ behavior: `smooth` })
---------------------------------------------------------------------------------






////////////////////////////////////////
// Types of events and event handlers //
////////////////////////////////////////

// Events:
// an event is a signal generated by a certain dumb node, so when something happens.

// There are 3 main methods to add event listeners:

//  1.  using on-event propery directly on the element
//      element.onmouseenter = function() {...};
//      this is the old way of attaching events

//  2.  add event in HTML like: onclick="alert(`hello`)"
//      never use this

//  3.  element.addEventListener(`mouseenter`, function() {...})
//      it allows to add multiple event listeners to the same event.
//      also it allows you to remove an event listener
//      element.removeEventListener(`eventType`, functionId)
//      you can remove it in setTimeout() or, for example, in the end of the callback to execute is once

// EXAMPLE:
const h1 = document.querySelector(`h1`);

const alertH1 = function (e) {
  alert(`Hello! Mouse is hovered...`);

  // remove event listener in the end
  h1.removeEventListener(`mouseenter`, alertH1);
};

// mouseenter is like :hover in css
h1.addEventListener(`mouseenter`, alertH1);






///////////////////////////////////////////////
// Event propagation: bubbling and capturing //
///////////////////////////////////////////////

// JS have important property: capturing phase and a bubbling phase.
// For example if you click on anchor link an event happens,
// but, usually, the event is not generated on the anchor link element, but in the root document.

// The way of event:
//  1.  Most of events are generated in the root element
//  2.  Capturing phase: event then travels all the way down from the document route to the target element.
//      Event is passing through every single parent element.
//  3.  Target pahes: when event reach the target and can be handled right at the target.
//      We're handling the events with event listeners and attach there callback function
//  4.  Bubbling phase: event then travels all the way up to the document route again
//      the event passes through all its parent elements againg (not any sibling elements)

// (!)
// Bubbling is important because if you attach the same event listener, also for example,
// to the parent element, then you would get the exact same result (callback)
// so you would have handled the exact same event twice

// Note: not all type of event do Capturing and Bubbling (but almost any)







/////////////////////////////////
// Event propagation: practice //
/////////////////////////////////


// Now if you click on child element (<a>) also both parent elements'll change background color
// This happens because parent elements handles the event listener also on children (during bubbling)


// IMPORTANT:
// `event.target`         --> is element where events happens and not the element where event listener is attached
// `event.currentTarget`  --> is element on which is attached the event listener and not element where event happens
// so: event.currentTarget === `this` keyword


// You can stop the event propagation (parent elements don't handel event of children)
// event.stopPropagation();


// You can catch events during the Capturing and not Bubbling (default)
// To do that you need to set the 3rd parameter of addEventListener() to true
// element.addEventListener(`event`, callback, boolean)
// so if  `true`: the event handler will no longer listen to bubbling events but instead, to capturing events.
// if `false` default the event handler will listen during bubbling
// NOT really usuful in modern days



EXAMPLE:
---------------------------------------------------------------------------------
// function which creates a random number between MIN and MAX
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1)) + min;

// 3 event listeners on <a>, <li> and <nav> (where last is parent) to change color on random on click
document.querySelector(`.nav__link`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);

  // stop event propagation
  e.stopPropagation();
});

document.querySelector(`.nav__links`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});

document.querySelector(`.nav`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});
---------------------------------------------------------------------------------







////////////////////////////////////////////////////
// Event delegation: implementing page navigation //
////////////////////////////////////////////////////



---------------------------------------------------------------------------------
NOT EFFICIENT WAY:

// this works fine but it's not efficient
// because I added the exact same callback function 3 times (unnecessary)
// if I have 1000 elements it's gonna affect the performance by copiing the callback 1000 times...



// get the nodeList of all `.nav__link` and attach event listener to all of them
document.querySelectorAll(`.nav__link`).forEach(function (element) {
  element.addEventListener(`click`, function (event) {
    // prevent default behavior for all events (moving to href="#id")
    event.preventDefault();

    // get the href attribute of the current element
    const id = element.getAttribute(`href`); // example output: "#section--3"

    // so onclick scrollIntoView to that id
    document.querySelector(id).scrollIntoView({ behavior: `smooth` });
  });
});

---------------------------------------------------------------------------------
EFFICIENT WAY USING EVENT DELEGATION:

// The better solution is to use event delegation
// so we use the fact that event is bubbled up
// so we need to attach event listener to the common parent (container) of all interested elements.


//  add event listener to common parent (container) of all interested elements.
document
  .querySelector(`.nav__links`)
  .addEventListener(`click`, function (event) {
    // prevent default behavior
    event.preventDefault();

    // determine what element originated the event
    const eventElement = event.target;

    // check if eventElement is actually interested element (.nav__link)
    if (eventElement.classList.contains(`nav__link`)) {

      // if it's interested element get the href attribute of the element and store it in "idHref"
      const idHref = eventElement.getAttribute(`href`);

      // then scroll to that id "idHref"
      document.querySelector(idHref).scrollIntoView({ behavior: `smooth` });
    }
  });
---------------------------------------------------------------------------------







////////////////////
// DOM traversing //
////////////////////


// Traversing = you can select an element based on another element.
//              (like direct child or a direct parent element)
// indeed you can also set this properties or set, for example, their style (not only read)



const h1 = document.querySelector(`h1`);



// ------------------- CHILDREN ------------------- //



//    element.querySelectorAll(`...`)
// return Nodelist with CHILDREN elements and doesn't matter how deep they are
console.log(h1.querySelectorAll(`.highlight`));

//    element.childNodes
// return NodeList with all direct children
console.log(h1.childNodes);

//    element.children
// return HTMLCollection (live collection) with all direct children real elements (for example no comments)
console.log(h1.children);

//    element.firstElementChild
// return first element child of HTMLCollection
console.log(h1.firstElementChild);
h1.firstElementChild.style.color = `white`; // example of setting style

//    element.lastElementChild
// return last element child of HTMLCollection
console.log(h1.lastElementChild);



// ------------------- PARENTS ------------------- //



//    element.parentNode
// return the Nodelist/element direct parent
console.log(h1.parentNode);

//    element.parentElement
// return the direct parent (usually use this)
console.log(h1.parentElement);

//    element.closest(`.container/#section1/h1`)
// return Nodelist/element with PARENTS elements and doesn't matter how deep (up) they are
console.log(h1.closest(`header`));
console.log(h1.closest(`h1`)); // return the same element



// ------------------- SIBLINGS ------------------- //



//    element.previousElementSibling
// return the previous direct sibling
console.log(h1.previousElementSibling);

//    element.nextElementSibling
// return the next direct sibling
console.log(h1.nextElementSibling);

//    element.previousElementSibling
// return the NodeList with previous direct sibling
console.log(h1.previousSibling);

//    element.nextElementSibling
// return the NodeList with next direct sibling
console.log(h1.nextSibling);

//    element.parentElement.children
// return the HTMLCollection with all siblings (element inclusive)
console.log(h1.parentElement.children);

// do something with all siblings but not element itself
[...h1.parentElement.children].forEach(function (element) {
  if (element !== h1) {
    console.log(`Do something here with siblings`);
  }
});







/////////////////////////////////
// Building a tabbed component //
/////////////////////////////////

// selecting elements to work with tabs
const tabsContainer = document.querySelector(`.operations__tab-container`);
const tabsBtns = document.querySelectorAll(`.operations__tab`);
const tabsContents = document.querySelectorAll(`.operations__content`);

// using event delegation, so add event listener on container
tabsContainer.addEventListener(`click`, function (event) {
  // preventing default just to be sure (not really necessary)
  event.preventDefault();

  // get the element (during bubbling) which provocated event --> event.target
  // and find the actual button because there is the <span> inside --> .closest(`.operations__tab`);
  const clickedBtn = event.target.closest(`.operations__tab`);

  // if `clickedBtn` is null so there was a click on container and not button then just exit function
  if (!clickedBtn) return;

  // otherwise get the `data-tab` attribute to understand which content should be shown
  const numberContent = clickedBtn.dataset.tab;

  // remove active class from all tab buttons
  // and add active class only on clicked tab button
  tabsBtns.forEach(el => el.classList.remove(`operations__tab--active`));
  clickedBtn.classList.add(`operations__tab--active`);

  // remove active class from all <div>s with content to show
  // and add active class only to <div> with correct numberContent class
  tabsContents.forEach(el =>
    el.classList.remove(`operations__content--active`)
  );
  document
    .querySelector(`.operations__content--${numberContent}`)
    .classList.add(`operations__content--active`);
});







/////////////////////////////////////////
// Passing arguments to event handlers //
/////////////////////////////////////////


// NOTE:
//  `mouseover` and `mouseout` do bubbling
//  `mouseenter` and `mouseleave` don't do bubbling


const changeOpacityNav = function (event, opacity) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = opacity;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = opacity;
  }
};

const navBar = document.querySelector(`.nav`);

navBar.addEventListener(`mouseover`, function (event) {
  changeOpacityNav(event, 0.5);
});

navBar.addEventListener(`mouseout`, function (event) {
  changeOpacityNav(event, 1);
});




//// --------------- BEST SOLUTION --------------- ////




// The best way to pass argument into an event handlers' callback function
// is to use bind method, set the `this` keyword and pass `this` as variable inside the callback body
// any event handler function can have only 1 real argument, which is the `event`
// if you want to pass more arguments set `this` in bind to an array or object

const navBar = document.querySelector(`.nav`);

const changeOpacityNav = function (event) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = this;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = this;
  }
};

navBar.addEventListener(`mouseover`, changeOpacityNav.bind(0.5));
navBar.addEventListener(`mouseout`, changeOpacityNav.bind(1));







////////////////////////////////////////////////////////
// Implementing a sticky navigation: the scroll event //
////////////////////////////////////////////////////////



//// -------------- OLD BAD SOLUTION -------------- ////



// REMEMBER:
// const navBar = document.querySelector(`.nav`);
// const section1 = document.getElementById(`section--1`);

// calculate the coordinates of section1
const seciton1Coordinates = section1.getBoundingClientRect();

window.addEventListener(`scroll`, function () {
  if (window.scrollY > seciton1Coordinates.top) {
    navBar.classList.add(`sticky`);
  } else {
    navBar.classList.remove(`sticky`);
  }
});







///////////////////////////////////
// The intersection Observer API //
///////////////////////////////////

