

(!)     ENGLISH LANGUAGE VERSION


(!)     Some of examples are coming from Jonas Schmedtmann's 
        complete JavaScript course on Udemy.
        I recommend this course to everyone! it's really good.
        And it's not an advertising but it's just my personal opinion.






        //////////////////////////
        //////////////////////////
        //// JAVASCRIPT NOTES ////
        //////////////////////////
        //////////////////////////



00. JAVASCRIPT FUNDAMENTALS (part 1)
        - definition
        - variables
        - operators
        - template strings
        - if else
        - conversation and coerecion
        - Truthy and Falsy Values
        - The Switch Statement        
        - Statements and Expressions
        - Conditional (ternary) operator

01. JAVASCRIPT FUNDAMENTALS (part 2)
        - Activating strict mode
        - Functions
        - Functions Declaration vs expression
        - Arrow Functions
        - Functions calling other functions
        - Arrays
        - JavaScript Array Methods and Propertie
        - Objects
        - Objects methods
        - Objects built in methods
        - the for loop
        - the while loop

02. DEVELOPER SKILLS AND EDITOR SETUP
        - setting up prettier
        - snippets
        - install node.js and dev environment

03. DOM AND EVENTS FUNDAMENTALS     
        - basics
        - handling click events
        - modal window and more about events

04. HOW JAVASCRIPT WORKS BEHIND THE SCENES        
        - a high level overview of JS
        - JS engine and runtime
        - execution contexts and the call stack
        - scope and the scope chain
        - hoisting and the TDZ
        - The this keyword
        - Regular functions vs Arrow functions
        - Primitive vs Objects (Primitive vs Reference Types)

05. DATA STRUCTURES, MODERN OPERATORS AND STRINGS        
        - Destructuring Arrays
        - Destructuring Objects
        - The spread operator (...)
        - Rest Pattern and Parameters
        - Short Circuiting (&& and ||)
        - Nullish coalescing operator
        - Logical assignment operator
        - Looping Arrays: The for-of Loop
        - Enhanced object literals 
        - Optional Chaining (?.)
        - Looping Objects: keys, values and entries
        - Sets
        - Maps
        - Which Data Structure to Use
        - Working with strings

06. A CLOSER LOOK AT THE FUNCTIONS
        - Default parameters
        - How passing arguments works: value vs reference
        - First-class and higher-order functions
        - Functions accepting the callback functions
        - Functions returning functions
        - The call and apply methods
        - The bind method
        - Immediately Invoked Function Expressions (IIFE)
        - Closures

07. WORKING WITH ARRAYS
        - Simple Array Methods
        - The at() method
        - Looping arrayes with forEach() method
        - forEach() method with Maps and Sets
        - Manipulating DOM Elements
        - Data transformations: map() 
        - Data transformations: filter()
        - Data transformations: reduce()
        - Data transformations: find()
        - Data transformations: findIndex()
        - Data transformations: some() and every()
        - Data transformations: flat() and flatMap()
        - Data transformations: sort()
        - Data transformations: fill() and Array.from()

08. NUMBERS, DATES AND TIMERS        
        - Converting and Checking Numbers
        - Math and Rounding
        - The remainder operator
        - Numeric separators 
        - Working with BigInt
        - Creating dates
        - Operations with dates
        - Internationalizing dates (INTL)
        - Internationalizing numbers (INTL)
        - Timers: setTimeout and setInterval

09. ADVANCED DOM AND EVENTS
        - How the DOM really works 
        - Selecting, creating and deleting elements
        - Styles, attributes and classes
        - Implementing Smooth scrolling 
        - Types of events and event handlers
        - Event propagation: bubbling and capturing
        - Event propagation: practice 
        - Event delegation: implementing page navigation         
        - DOM traversing
        - Building a tabbed component
        - Passing arguments to event handlers
        - Implementing a sticky navigation: the scroll event
        - 
        - 
        - 
        -      
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        -              

___________________________________________________________________________________________________________________________________
00. JAVASCRIPT FUNDAMENTALS (part 1)



JavaScript is a hight level, objet oriented, multi-paradigm programming language.
    programming language    ->  instructions for computer
    hight level             ->  easier language (no memory management)
    objet oriented          ->  based on objects to store data
    multi-paradigm          ->  allows to use different styles of programming (imperative and declerative programming)

3 core languages of web development:
    1.  HTML            (nouns)
    2.  CSS             (adjectives)
    3.  JAVASCRIPT      (verbs)

JS has multimple updates. One of the the biggest in last years was in 2015.
The update is ES6/ES2015    ->  E.S. = ECMAScript
In 2023 the "modern JS" means all updates after 2015.


JS code can be:
    -   putted inline script in hetml tag       <script>...</script>
    -   linked in a separate file               <script src="script.js" defer></script>
                                                defer ->    load in the ened on file (only external files)





Just random basics
----------------------------------------------------------
;                                       let JS know the instruction is finished (good practice)

console.log();                          show staff on console
console.warn();                         show waring on console
console.error();                        show error on console
console.table(objectName);              show table of an object on console

alert("Hello world")                    make an alert

// this is a comment

/* this is a multiline comment */

\n                                      new line

\t                                      tab

\                                       escaping character ex: "\"hello\" world"

clear()                                 clear console in browser

prompt("Enter something")               get promt windows (it's like an input from alert)
                                            ex: let age = promt("Enter your age: ")

debugger;                               statement to open debuger tool in this point
                                        (it's like put a breakpoint in debugger)


                                        
----------------------------------------------------------


(!) DRY = don't repeat yourself
    It's a principle to don't repeat the same code

    Refactoring = means to restructure the code but without changing how it works.
    We do refactoring to improve the code and to eliminate duplicate code.



///////////////
// variables //
///////////////

we can store a value in variables
(value = piece of data)    



var firstName = "Jonas";
    var is legacy (old) way of declaring variables.
    it works as "let"


let firstName = "Jonas";    
    let is used to mutate (reassign) the variable subsequently
    We can declare empty variables.

    EXAMPLE:
    let birthYear = 1996;
    birthYear = 1997;


const firstName = "Jonas";
    const is used for variables which are not supposed to change
    so const is used for immutable variables.
    We can't declare empty variables.

    EXAMPLE:
    const birthYear = 1996;
    birthYear = 1997;
    // TypeError



The way of calling variable is called camelCase.
    camelCase means 1st word is lowercase and other word starts with uppercase 
    and all the words are connected. camelCase is standard in JS.

Variables:
    - can't start with a number like "3years"
    - can contain only letters, numbers, _, $
    - can't be the same as a reserved keywords like "new"
    - better don't use "name" 
    - all in uppercase means it's a constant like:  let PI = 3.1415;

Every value is an object or a primitive value.
primitive value:
let firstName = "Jonas";

object:
let me = {
    name: "Jonas";
}


primitive data types:
    - numbers
        floating point numbers used for decimals and integers
        23, 23.1

    - strings
        sequence of character put inside the ""
        "Hello World"

    - boolean
        true or false

    - undefined
        value is taken by a variable that is not yet defined (empty value)  
        let children;

    - null
        empty value

    - symbol
        (ES2015) value is unique and can't ba changed

    - bigInt
        larger integers than the numbers type can hold


(!) JS has dynamic typing
    We don't need manually define the data type of a value stored in a variable,
    the data types are determined automatically.
    Also the variables can be reassigned with different values.


typeof  ->  operator which shows the data type of a variable
    EXAMPLE:
    console.log(typeof true);
    // boolean

There is a weird bug in JS.
When we run:
    console.log(typeof null);
    // object   -> but it's not an object



(!) We need to use "let" when we create a variable,
    but we don't need to use it to change the value of a variable.

    EXAMPLE:
    let JavaScriptIsFun = true;
    JavaScriptIsFun = "YES!";





///////////////
// operators //
///////////////

operators = allows us to transform values or combine multiple values.

    1.  mathematical operators
        (+  -   *   /   **)


    2.  assignment operators
        (=  +=  -=  *=  /=  ++  --)

(!!!) NOTE: ++ operator increment the value but it return the original value (example: counter++)
            to return the updated value you need to write ++counter
            (same for --)


    3.  comparison operators
        (>  <   >=  <=)


    4.  equality operators
        (== ===)

        "2" == 2 (loose equality operator)        
            // true       ->     do type coercion
            // which basically means it's trying its best to convert 
            // both of the objects to similar data types to actually perform the comparison.
            // !=

        "2" === 2 (strict equality operator)        
            // false      ->     DO NOT type coercion
            // comparison based on data type space
            // !==


    5.  boolean logic operators

        AND
        >>>1 === 1 && 2 === 2
            // && = and

        OR
        >>>1 === 1 || 2 === 2
            //  || = or

        NOT
        >>>!(1===1)
            // ! = not 





//////////////////////
// template strings //
//////////////////////

// data for examples below
const firstName = "John";
let ageJohn = 39;
let currentYear = 2023;


Concatenation:
    console.log("Hello, my name is " + firstName + " and I'm " + ageJohn + " years old");

    console.log("String with \n\
    multiple \n\
    lines");


Template strings (uses ``):
    console.log(`Hello, my name is ${firstName} and I'm ${ageJohn} years old`);
    console.log(`${currentYear - ageJohn}`);

    console.log(`String with
    multiple
    lines`);





/////////////
// if else //   ->  official name: Control Structure
/////////////


IF STATEMENT
if (condition 1){
       // execute some code;
}else if (condition 2){
       // execute some other code;
}else if (condition 3){
       // execute some other code;
...
}else{
       // execute some backup code;
}


EXAMPLE:

    // data for example below
    const age = 16;
    const isOldEnaugh = age >= 18;

    if (isOldEnaugh) {
        console.log(`Can start driving`);
    } else {
        const yearLeft = 18 - age;
        console.log(`You're too young, and you can drive in ${yearLeft} years.`)
    }





////////////////////////////////
// conversation and coerecion //
////////////////////////////////

type conversion ->  we manually convert from one type to another
type coerecion  ->  when JavaScript automatically converts types


Number()    ->  function is used to convert a value to a number. ...

String()    ->  function is used to convert a value to a string. ...
                (!) you can convert a number to the string by adding number to empy string:
                    const newStr = number + ``;

Boolean()   ->  function is used to convert a value to a boolean. ...

Null()      ->  function is used to convert a value to null.


(!) These functions don't convert original value
    they just return a new value

EXAMPLE:
    const inputYear = `1991`;
    const inputYearNumber = Number(inputYear);





/////////////////////////////
// Truthy and Falsy Values //
/////////////////////////////

5 falsy values if we convert them in boolean:
    1.  0
    2.  `` (empty string)
    3.  undefined
    4.  null
    5.  NaN (not a number)





//////////////////////////
// The Switch Statement //
//////////////////////////

Switch Statement
    is an alternative way of writing a if/else statement, when all we want 
    to do is to compare one value to multiple different options.


EXAMPLE:
const day = `monday`;

switch(day) {                               // we are comparing `day`
    case `monday`:                          // to `Monday` in a strict equality way
        console.log(`plan studying`);       // so if day === `monday` the code below will be executed
        console.log(`go coding`);
        break;                              // without the break the code continues executing and it stops when it find a break
    case `tuesday`:
        console.log(`prepare video`);
        break;
    case `wednesday`:                       // run the same code for two different values
    case `thursday`:                        // to do that we need to specidy two cases in a row
        console.log(`do sport`);
        break;
    case `saturday`:
    case `sunday`:
        console.log(`engoy weekend`);
        break;
    default:                                // default will be executed only if all the other cases fail
        console.log(`not a valid day`);
}   





////////////////////////////////
// Statements and Expressions //
////////////////////////////////


expression
    is a piece of code that produces a value.
    EXAMPLE: 3 + 4
    EXAMPLE: 1991
    EXAMPLE: true && !false


statement
    is like a bigger piece of code that is executed
    and which does not produce a value on itself
    EXAMPLE:
    if (18>10) {
        const str = `18 is bigger`;
    }
 




////////////////////////////////////
// Conditional (ternary) operator //
//////////////////////////////////// 

conditional operator
    allows to to write something similar to an if/else statement
    but just in one line


syntax:
    condition ? code-if-condition-is-true : code-if-condition-is-false(else);


EXAMPLE #1:
    const age = 16;
    age >= 18 ? console.log(`I like drink wine`) : console.log(`I like drink water`);
    // output   ->  I like drink water


EXAMPLE #2:
    const drink = age >= 18 ? `wine` : `water`;



(!) since the ternary operator, is a expression it produces a value,
    so we can insert it inside of a template literal which accepts only expressions.

    EXAMPLE:
    console.log(`I like to drink ${age >= 18 ? `wine` : `water`}`);
    // output   ->  I like to drink water
 





___________________________________________________________________________________________________________________________________
01. JAVASCRIPT FUNDAMENTALS (part 2)





////////////////////////////
// Activating strict mode //
////////////////////////////

strict mode
    is a special mode that we can activate in JavaScript, which makes it easier 
    for us to write a secure JavaScript code.

(!) To activate the strict mode in JS we need to write in the very first line (1st statement):
    'use strict';

(!) We should always use the strict mode


Secure means that strict mode makes it easier for developers to avoid accidental errors.
It helps us introduce the bugs into our code.
strict mode:
    1.  forbids us to do certain things
    2.  it will actually create visible errors for us
        (when JS would just fail silently)
    3.  introduces a short list of variable names that are reserved for features
        that might be added to the language a bit later (EXAMPLE: let interface)





///////////////
// Functions //
///////////////


functions
    piece of code that we can reuse over and over again in our code
--------------------------------------------
syntax:     (function declaration)
--------------------------------------------
function functionName() {
    // function body
    console.log(`execute this code when we call func`);             
}

// calling / runing / invoking function
functionName()                                                      





--------------------------------------------
input data:     (function declaration)
--------------------------------------------

function fruitProcessor(apples, oranges) {  
    // apples, oranges -> input data of a function
    const juice = `Juice with ${apples} apples and ${oranges} oranges`
    // return keyword   ->  we can return any value from the function
    return juice;
}

const appleJuice = fruitProcessor(4, 0);
console.log(appleJuice);
console.log(fruitProcessor(4, 0));
// Juice with 4 apples and 0 oranges

(!) return will exits immediately from a function



/////////////////////////////////////////
// Functions Declaration vs expression //
/////////////////////////////////////////


In JavaScript, there are different ways of writing functions.

(!) In examples above we can see function declarations, 
    because we simply use the function keyword.





--------------------------------------------
function declaration:
--------------------------------------------

function calculateAge1(birthYear) {
    return 2023 - birthYear;
}

const age1 = calculateAge1(1996);





--------------------------------------------
function expression:
--------------------------------------------

const calculateAge2 = function (birthYear) {
    return 2023 - birthYear;
}

const age2 = calculateAge2(1996);

(!) function expression is a function without a name (also called an anonymous function),
    and it's an expression and remember that an expression produces a value.
    So we use that value to store it into calcAge2 variable.



(!) the main practical difference between function declarations and function expressions
    is that we can call function declarations before they are defined in the code.
    This is happening because of the process called hoisting.
    (this doesn't work with the expression)

    so we can write this:

    // calling function
    const age1 = calculateAge1(1996);

    // defining function
    function calculateAge1(birthYear) {
    return 2023 - birthYear;
    }





//////////////////////
// Arrow Functions  //
//////////////////////
    
Arrow Functions are added to JavaScript in ES6.
Arrow Functions is a special form of function expression
that is shorter and faster to write.



--------------------------------------------
SYNTAX:
    variable = parameter => write what need to return;


EXAMPLE #1:
const calculateAge3 = birthYear => 2023 - birthYear;
const age3 = calculateAge3(1996);



--------------------------------------------
(!) we still need to use {} and return if we need to define a code block
    (have more lines of code)


EXAMPLE #2:
const yearsUntileRetirement = birthYear => {
    const age = 2023 - birthYear;
    const retirement = 65 - age;
    return retirement;
}
const retirementYears = yearsUntileRetirement(1996);



--------------------------------------------
(!) we need to wrap parameter inside parentheses ()
    if we have more then 1 parameter.


EXAMPLE #3:
const yearsUntileRetirement = (birthYear, firstName) => {
    const age = 2023 - birthYear;
    const retirement = 65 - age;
    return `${firstName} retires in ${retirement} years`;
}
const retirementYears = yearsUntileRetirement(1996, `Alex`);
console.log(retirementYears);

// or we can just write
// console.log(yearsUntileRetirement(1996, `Alex`));



--------------------------------------------
(!) There is a difference between the arrow function and 
    traditional functions (function declarations and function expressions).
    arrow functions don't have `this` keyword and also `arguments` keyword.

    arguments -> show all arguments when calling function





///////////////////////////////////////
// Functions calling other functions //
///////////////////////////////////////

function cutFruitInPieces(fruit) {
    return fruit * 4;
}

function fruitProcessor(apples, oranges) {  
    const applePieces = cutFruitInPieces(apples);
    const OrangePieces = cutFruitInPieces(oranges);

    const juice = `Juice with ${applePieces} pieces of apples and ${OrangePieces} pieces of oranges`
    return juice;
}





////////////
// Arrays //
////////////


Arrays 
    Arrays are a data structure like a big container into which 
    we can throw variables and then later reference them.

    Array is not a primitive value so it's mutable even if we use `conts` to declare it

    (!) but we can't replace an array
        so we CAN'T do this:
        const friends = [`Michael`, `Steven`, `Peter`];
        friends = [`Mattia`, `Paolo`];                      // TypeError

    Inside an array we can put variables, different data types and other arrays



--------------------------------------------
const friends = [`Michael`, `Steven`, `Peter`];
const years = new Array(1996, 1994, 2001);

(!) instead of [] we can use `new Array()` 
    new         keyword
    Array()     function


console.log(friends[0]);                            // 1st element
console.log(friends.length);                        // array length
console.log(friends[friends.length - 1]);           // last element

(!) inside the [] we can put an expression (produces a value).

friends[2] = "Sasha"                                // change the value in that index





////////////////////////////////////////////
// JavaScript Array Methods and Propertie //
////////////////////////////////////////////

array.method(parameter);


at()	            Returns an indexed element of an array
concat()	        Joins arrays and returns an array with the joined arrays
constructor	        Returns the function that created the Array object's prototype
copyWithin()	    Copies array elements within the array, to and from specified positions
entries()	        Returns a key/value pair Array Iteration Object
every()	            Checks if every element in an array pass a test
fill()	            Fill the elements in an array with a static value
filter()	        Creates a new array with every element in an array that pass a test
find()	            Returns the value of the first element in an array that pass a test
findIndex()	        Returns the index of the first element in an array that pass a test
flat()	            Concatenates sub-array elements 
flatMap()	        Maps all array elements and creates a new flat array
forEach()	        Calls a function for each array element
from()	            Creates an array from an object
includes()	        Check if an array contains the specified element (returns true or false)
indexOf()	        Search the array for an element and returns its position (index)
isArray()	        Checks whether an object is an array
join()	            Joins all elements of an array into a string
keys()	            Returns a Array Iteration Object, containing the keys of the original array
lastIndexOf()	    Search the array for an element, starting at the end, and returns its position
length	            Sets or returns the number of elements in an array
map()	            Creates a new array with the result of calling a function for each array element
pop()	            Removes the last element of an array, and returns that element
prototype	        Allows you to add properties and methods to an Array object
push()	            Adds new elements to the end of an array, and returns the new length
reduce()	        Reduce the values of an array to a single value (going left-to-right)
reduceRight()	    Reduce the values of an array to a single value (going right-to-left)
reverse()	        Reverses the order of the elements in an array
shift()	            Removes the first element of an array, and returns that element
slice()	            Selects a part of an array, and returns the new array
some()	            Checks if any of the elements in an array pass a test
sort()	            Sorts the elements of an array
splice()	        Adds/Removes elements from an array
toString()	        Converts an array to a string, and returns the result
unshift()	        Adds new elements to the beginning of an array, and returns the new length
valueOf()	        Returns the primitive value of an array


example:            let boolResult = friends.includes(`Steven`);

--------------------------------------------





/////////////
// Objects //
/////////////


Object
    In Objects we define key:value pairs like dictionaries in python.
    Objects can hold different types of data.
    Every key:value pair is 1 property.
    Object()    Turns the input into an object.


SYNTAX:
variable = {
    key: value;
}



EXAMPLE:
const john = {
    firstName: `John`,                          // property 1
    lastName: `Wick`,                           // property 2 ...
    age: 2023 - 1996,                           
    job: `hacker`,
    friends: [`Bander`, `Lila`, `Mattia`]
}



// get property
console.log(john.lastName);
console.log(john[`lastName`]); 

// add property
john.location = `China`;
john[`location`] = `China`;


(!) inside [] we can put any expression
    EXAMPLE:
    const nameKey = `Name`;
    console.log(john[`last` + nameKey]); 
    console.log(john[`first` + nameKey]); 





/////////////////////
// Objects methods //
/////////////////////

Any function that is attached to an object is called a method.

(!) if functions are another type of value means that we can 
    create a key value pair in which the value is a function,
    so we can add functions inside an object.
    
    That works because the expression produces the value,
    and function declaration will NOT work.



const john = {

    firstName: `John`,                                      // string value
    lastName: `Wick`,                           
    birthYear: 1996,                           
    job: `hacker`,
    friends: [`Bander`, `Lila`, `Mattia`],                  // array value
    hasDriverLicense: true,                                 // boolean value



    // key(name-of-function): function-expression
    calcAge: function (birthYear) {                         // function value
        return 2023 - birthYear;
    },



    // using `this`
    calcAge2: function () {
        return 2023 - this.birthYear;
    },



    // most efficient solution
    calcAge3: function () {

        // creating a new property with this.age
        this.age = 2023 - this.birthYear;    
        return this.age;
    }
}


(!) `this` keyword is basically equal to the object on which the method is called
    (it is equal to the object calling the method)



// access to function property
john.calcAge(1996);
john[`calcAge`](1996);


// access to function property using `this`
john.calcAge2();


// calling the func property creating the new property and 
// then acceess directly to the new property
john.calcAge3();
john.age





//////////////////////////////
// Objects built in methods //
//////////////////////////////


Object.assign()
        Copies the values of all enumerable own properties from one or 
        more source objects to a target object. Works on 1st level (not nested staff)

Object.create()
        Creates a new object with the specified prototype object and properties.

Object.defineProperties()
        Adds the named properties described by the given descriptors to an object.

Object.defineProperty()
        Adds the named property described by a given descriptor to an object.

Object.entries()
        Returns an array containing all of the [key, value] pairs of a 
        given object's own enumerable string properties.

Object.freeze()
        Freezes an object. Other code cannot delete or change its properties.

Object.fromEntries()
        Returns a new object from an iterable of [key, value] pairs. 
        (This is the reverse of Object.entries).

Object.getOwnPropertyDescriptor()
        Returns a property descriptor for a named property on an object.

Object.getOwnPropertyDescriptors()
        Returns an object containing all own property descriptors for an object.

Object.getOwnPropertyNames()
        Returns an array containing the names of all of the given object's
        own enumerable and non-enumerable properties.

Object.getOwnPropertySymbols()
        Returns an array of all symbol properties found directly upon a given object.

Object.getPrototypeOf()
        Returns the prototype (internal [[Prototype]] property) of the specified object.

Object.groupBy() Experimental
        Groups the elements of a given iterable according to the string values 
        returned by a provided callback function. The returned object has separate 
        properties for each group, containing arrays with the elements in the group.

Object.hasOwn()
        Returns true if the specified object has the indicated property as its
        own property, or false if the property is inherited or does not exist.

Object.is()
        Compares if two values are the same value. Equates all NaN values 
        (which differs from both IsLooselyEqual used by == and IsStrictlyEqual used by ===).

Object.isExtensible()
        Determines if extending of an object is allowed.

Object.isFrozen()
        Determines if an object was frozen.

Object.isSealed()
        Determines if an object is sealed.

Object.keys()
        Returns an array containing the names of all of the given 
        object's own enumerable string properties.

Object.preventExtensions()
        Prevents any extensions of an object.

Object.seal()
        Prevents other code from deleting properties of an object.

Object.setPrototypeOf()
        Sets the object's prototype (its internal [[Prototype]] property).

Object.values()
        Returns an array containing the values that correspond to all of a 
        given object's own enumerable string properties.



--------------------------------------------
Instance properties

(!) These properties are defined on Object.prototype and shared by all Object instances.

(OLD) Object.prototype.__proto__
        Points to the object which was used as prototype when the object was instantiated.

Object.prototype.constructor
        The constructor function that created the instance object. 
        For plain Object instances, the initial value is the Object constructor. 
        Instances of other constructors each inherit the constructor property 
        from their respective Constructor.prototype object.


--------------------------------------------
Instance methods


(OLD) Object.prototype.__defineGetter__()
        Associates a function with a property that, when accessed, 
        executes that function and returns its return value.

(OLD) Object.prototype.__defineSetter__()
        Associates a function with a property that, when set, 
        executes that function which modifies the property.

(OLD) Object.prototype.__lookupGetter__()
        Returns the function bound as a getter to the specified property.

(OLD) Object.prototype.__lookupSetter__()
        Returns the function bound as a setter to the specified property.

Object.prototype.hasOwnProperty()
        Returns a boolean indicating whether an object contains the 
        specified property as a direct property of that object and not 
        inherited through the prototype chain.

Object.prototype.isPrototypeOf()
        Returns a boolean indicating whether the object this method 
        is called upon is in the prototype chain of the specified object.

Object.prototype.propertyIsEnumerable()
        Returns a boolean indicating whether the specified property is 
        the object's enumerable own property.

Object.prototype.toLocaleString()
        Calls toString().

Object.prototype.toString()
        Returns a string representation of the object.

Object.prototype.valueOf()
        Returns the primitive value of the specified object.





//////////////////
// the for loop //
//////////////////



for(a; b; c) {
    // some code
}

    a   ->  initial counter 
    b   ->  logical condition that is evaluated before each iteration of loop
            if the condition is true the next iteration will run.
    c   ->  increase the counter after each iteration


(!) continue    -> exit the current iteration of the loop and contunue to the next one
    break       -> completely terminate the whole loop



EXAMPLE #1:     // basics
for(let rep = 1; rep <= 10; rep++){
    console.log(`Doing the repitition number ${rep}`);
}



EXAMPLE #2:     // normal
const friends = [`Michael`, `Steven`, `Peter`, 13];
const dataTypes1 = [];
const dataTypes2 = [];

for(let i = 0; i < friends.length; i++){
    console.log(friends[i]);
    dataTypes1[i] = typeof friends[i];
    dataTypes2.push(typeof friends[i]);
}



EXAMPLE #3:     // advanced
const years = [1996, `Sasha`, 1998, 2004, 1989];
const ages = [];

for(let i = 0; i < years.length; i++){
    if(typeof years[i] !== `number`) continue;
    ages.push(2023 - years[i]);
}



EXAMPLE #4:     // loop backwards
const years = [1996, `Sasha`, 1998, 2004, 1989];

for(let i = years.length -1; i >= 0; i--){
    console.log(years[i]);
}



EXAMPLE #4:     // loop inside a loop

for (let exercise = 1; exercise < 4; exercise++) {
    console.log(`------------starting exercise #${exercise}`);
    for (let repitition = 1; repitition < 6; repitition++){
        console.log(`Exercise #${exercise}. Lifting the weith of repitition #${repitition}`);
    }
}





////////////////////
// the while loop //
////////////////////

The while loop has only the condition to be checked.
And it's running until the condion is true.
It doest'y need a counter, so it can be used in a larger variety of situations.
(and we can always specify the counter manually creating the variabile outside 
the loop and then increase after every iteration)


// creating a random number between 1-6
let dice = Math.trunc(Math.random() * 6) +1;

while(dice !== 6) {
    console.log(`You rolled ${dice}`);
    dice = Math.trunc(Math.random() * 6) +1;
    if (dice === 6) {
        console.log(`Nice the dice is ${dice} and the loop is ending...`)
    }
}
 





___________________________________________________________________________________________________________________________________
02. DEVELOPER SKILLS AND EDITOR SETUP





/////////////////////////
// setting up prettier //
/////////////////////////


Prettier is an opinionated code formatter which means that it makes 
assumptions about how good code should look like.

1.  This tool is available as a VS Code extension. Download it.

2.  Now define Prettier as the default formatter of our code.
    settings > search: default formatter -> select esbenp.prettier-vscode
    (also chech `format on save` is on)

3.  We can configure the Prettier by creating a file ".prettierrc" inside the project folder
    go to prettie website > options > configuratin prettier documentation
    then inside the folder we can change the default behavior of this tool.

    EXAMPLE:
    {
        "singleQuotes": true,
        "arrowParens": "avoid"
    }





//////////////
// snippets //
//////////////

Snippets make the coding faster.

in vs code:

1.  file > preferences > user snippets > new global snippets file... > anyCustomName

2.  In this file we can define a the snippets.#

    EXAMPLE:
	"Print to console": {
		"scope": "javascript,typescript",
		"prefix": "cl",
		"body": ["console.log();"],
		"description": "Log output to console"
    }

    Now you write `cl` + ENTER  ->  console.log();





/////////////////////////////////////////
// install node.js and dev environment //
/////////////////////////////////////////

To automatically reload changes on save while coding we can download live server extension.
There is a more professional way of running Live Server by using Node.js
Node.js is a JavaScript runtime.

1.  google node.js 
    download and install node.js from the official website

2.  after installing it will become available as a program in terminal.

    in terminal: `node -v` to see the version and be sure node.js is installed
    in terminal: `npm install live-server -g`
    in terminal: `live-server`
        it will then open the index.html file by default in the current folder
 





___________________________________________________________________________________________________________________________________
03. DOM AND EVENTS FUNDAMENTALS 





////////////
// basics //
////////////

DOM = Document Object Model
    Structured representation of HTML documents. 
    It allows JS to acceess HTML elements and style to manipulate them.

The DOM is automatically created by the browser as soon as the HTML page loads.
And it's stored in a tree structure.
In this tree, each HTML element is one object.

The Document is the entry point to the DOM (main element of the tree).
Usually the first child is the HTML element, which is the root of html files.
And it hase the method querySelector() to selec an element.



(!) JavaScript is actually just a dialect of the ECMAScript specification,
    and all this DOM related stuff is not in there, so DOM is not a part of JS.

    DOM and DOM methods are part of something called the web APIs.
    The web APIs are like libraries (written in JS) that browsers implement and that 
    we can access from our JavaScript code.
    And API stands for Application Programming Interface.

--------------------------------------------

in console of a browser in a website:
document                    =>     return HTML text of the page
console.dir(document)       =>     return DOM with all the properties and values


HTML elements are the properties of the DOM (Object)
Some of important document attriburtes:
       document.URL     --      This is the actual URL of the website
       document.body    --      This is everything inside of the body
       document.head    --      This is everything in the head of the page
       documnet.links   --      These are all the links on the page

There are many methodas to grab elements form the DOM:
       document.getElementById()                 => as the parameter, pass an id of HTML element                => ex: document.getElementById("pickme")
       document.getElementsByClassName()         => as the parameter, pass a class of HTML elements             => ex: document.getElementsByClassName("myul")
       document.getElementsByTagName()           => pass the tag like anchor tag                                => ex: document.getElementsByTagName("li")
       document.querySelector()                  => returns the first object matching the CSS style selector    => ex: document.querySelector("#pickme")
       document.querySelectorAll()               => returns all objects matching the CSS style selector         => ex: document.querySelectorAll(".myul")



EXAMPLE:
    // document . selector Method . element . element attribute
    document.querySelector(`.number`).textContent = 22;

    // `value` property for input feld
    document.querySelector(`.input`).value = 13;



(!) To change the style we need to grab the element
    then apply to `style` attriburte
    then set the new value inside the ` `

    use the camelCase notation instead of -
    for example:
    wrong:      background-color
    correct:    backgroundColor   

    EXAMPLE:
    document.querySelector(`body`).style.backgroundColor = `white`;

--------------------------------------------





///////////////////////////
// handling click events //
///////////////////////////


Event = something that happens on the page
        (mouse click, mouse moving, key press...)

Event listener = allows to wait a certain event to happen and then react to it.

To do:
1.  need to select an element on which an evenet should happen

2.  then we need to add the event listener method on that element

    SYNTAX: 
    element.addEventListener(x, y)
    x   ->  type of the event
    y   ->  event handler (function VALUE with code that should happen on event)



3.  EXAMPLE #1:
    document.querySelector(`.btn`).addEventListener(`click`, function () {
    //    `.btn` is our button element
    //    `click` is the event
    //    the code below is event handler function value
    console.log(document.querySelector(`.guess`).value);

    // (!)    we DON'T need to call the event handler function
    //        JavaScript engine will call this function as soon as the event happens
    });


    EXAMPLE #2:
    document.getElementById("myBtn").addEventListener("click", displayDate);





////////////////////////////////////////
// modal window and more about events //
////////////////////////////////////////


The best way to make changes on the website is working with the css classes,
because change every value of every property is really inefficient.


--------------------------------------------
EXAMPLES of classes:


/* CLASSES TO MAKE MODAL WORK */

.hidden {
  display: none;
}

.modal {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 70%;

  background-color: white;
  padding: 6rem;
  border-radius: 5px;
  box-shadow: 0 3rem 5rem rgba(0, 0, 0, 0.3);
  z-index: 10;
}

/*  <div class="overlay hidden"></div>  */
.overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(3px);
  z-index: 5;
}

--------------------------------------------


(!) To work with classes we can use Element.classList is a read-only property
    which returns a list of class attributes of the element.

    We can modify the tokens of the list using:
    -   add()
    -   remove()
    -   replace()
    -   toggle()
    -   contains()

    syntax: element.classList.method(`class-name`)
            DON'T USE . # (we are not selecting elements)



EXAMPLE:

// eterating thrue the list of `btnsOpenModal` buttons list
for (let i = 0; i < btnsOpenModal.length; i++) {
  // add EventListener for every element of the list
  btnsOpenModal[i].addEventListener(`click`, function () {
    modal.classList.remove(`hidden`);
    overlay.classList.remove(`hidden`);
  });
}

--------------------------------------------

(!) keyboard events are global events because they don't happen on a specific element.
    And for global events like keyboard events we usually listen on the whole document.

    // this will happen for EVERY key pressed
    document.addEventListener(`keydown`, function);

    there are 3 type of keyboard event:
        1. `keydown`    just press down the key
        2. `keypress`   fired continuously as the finger is on the key
        3. `keyup`      when lift off the finger 



(!) information about which key was pressed is stored in the event
    so everytime we press a key a `keydown` event is generated
    and JS generates an object which contains all the information about the event
    and we can access that object in the event handler function passing it as parameter.

    syntax:

    // listening for events everywhere
    // we can call `event` parameter as we want, for example `pizza`
    document.addEventListener(`keydown`, function (event) {
    console.log(event);
    });



(!) It's always a good idea to console.log(event) and analize it

    since the event is an object, we have access to it's 
    properties and values like a normal object
    
    for example we can access on the value of which key was pressed:
    console.log(event.key);


EXAMPLE:

// listening for events everywhere
// we can call `event` parameter as we want, for example `pizza`
document.addEventListener(`keydown`, function (event) {
  if (event.key === `Escape` && !modal.classList.contains(`hidden`)) {
    closeModal();
  }
});
 





___________________________________________________________________________________________________________________________________
04. HOW JAVASCRIPT WORKS BEHIND THE SCENES 





/////////////////////////////////
// a high level overview of JS //
/////////////////////////////////



JAVASCRIPT IS A HIGH-LEVEL, PROTOTYPE-BASED OBJECT-ORIENTED, 
MULTI-PARADIGM, INTERPRETED OR JUST-IN-TIME COMPILED, 
DYNAMIC, SINGLE-THREADED, GARBAGE-COLLECTED PROGRAMMING 
LANGUAGE WITH FIRST-CLASS FUNCTIONS AND A NON-BLOCKING 
EVENT LOOP CONCURRENCY MODEL



--------------------------------------------
HIGH-LEVEL

Any computer program needs some hardware resources such as memory and the CPU to do its work.

low-level languages (like C)
    you have to manually manage these resources

high-level languages (like python)
    these languages have so-called abstractions, so resources are managed automatically.
    language easier to learn and to use but these programs will never be as fast as written un C.



--------------------------------------------
GARBAGE-COLLECTED

its an algorithm memory management inside the JavaScript engine
which automatically removes old, unused objects from the memory.



--------------------------------------------
INTERPRETED OR JUST-IN-TIME COMPILED

computer's processor only understands zeros and ones (machine code)
we write an abstraction over machine code which needs to be translated.
That step can be compiling or interpreting.
In case of JS it happens inside the JavaScript engine.



--------------------------------------------
MULTI-PARADIGM

Paradigm: An approach and mindset of structuring code, which will direct your coding style and technique.

3 Popular paradigms:
    1.  Procedural programming
            just organizing the code in a very linear way with some functions in between.
    2.  Object-oriented programming (OOP)
    3.  Functional programming (FP)

Paradigms can be:
    - Imperative
    - Declarative


object-oriented approach
    almost everything in JavaScript is an object
    except for primitive values such as numbers, strings, etc.

    prototypal inheritance is like make an object with all attributes nad methods
    and then we inherit these attributes in the instances, like push()
    method of an array (which is also an object)



--------------------------------------------
FIRST-CLASS FUNCTIONS

In a language with first-class functions, functions are simply treated as variables. 
We can pass them into other functions, and return them from functions.

So we can, for exaple, pass a function into another function as an argument.



--------------------------------------------
DYNAMIC

We don't assign data types to variables.

No data type definitions while creating a variable. Types becomes known at runtime.
Also data type of variable is automatically changed.

EXAMPLE:
let x = 23;
x = "Alex";



--------------------------------------------
NON-BLOCKING EVENT LOOP

Concurrency model: 
    how the JavaScript engine handles multiple tasks happening at the same time.

JavaScript runs in one single thread, so it can only do one thing at a time.
But we can use event loop.

Event loop:
    takes long running tasks, executes them in the “background”, 
    and puts them back in the main thread once they are finished





///////////////////////////
// JS engine and runtime //
///////////////////////////

JS Engine = computer program that executes JavaScript code.
            every browser has its own JavaScript engine.
            (most known engine is Google's V-Eight)

V8 engine powers Google Chrome and node.js
With node.js we can build server side applications without eny browser.

any JavaScript engine always contains:
    1.  call stack = where the code is executed using something called execution contexts
    2.  memory heap = is an unstructured memory pool which stores all the objects that our application needs



--------------------------------------------
--------------------------------------------
    Methods to translate code into machine code:
--------------------------------------------

Compilation: Entire code is converted into machine code at once, and written to a binary file that can be executed by a computer.

    CODE  ==comiplation==>  MACHINE CODE (portable)  ==execution==>  PROGRAM RUNNING


--------------------------------------------
Interpretation: Interpreter runs through the source code and executes it line by line

    CODE  ==execution line by line converting into machine code ==>  PROGRAM RUNNING

JS was purely interpreted language but it's really slower then compilation.#
Today low performance in not acceptable.
So the modern JS engine now use a mix between compilation and interpretation.
This mix is called just-in-time compilation.


--------------------------------------------
Just-in-time (JIT) compilation: Entire code is converted into machine code at once, then executed immediately

    CODE  ==compilation==>  MACHINE CODE(not portable)  ==execution immediatly==>  PROGRAM RUNNING



--------------------------------------------
--------------------------------------------
    How JavaScript Just-in-time (JIT) Compilation Works
--------------------------------------------

JIT:    PARSING  ==>  COMPILATION  ==>  EXECUTION  ==optimization multiple times==>  EXECUTION

1. PARSING
    a piece of JavaScript code enters the engine (parsing = reading the code)
    then the code is parsed into a data structure called the abstract syntax tree (AST):
        a.  splitting up each line of code into pieces that are meaningful to the language
        b.  then saving all these pieces into the tree in a structured way
            this step also checks if there are any syntax errors
            and the resulting tree will later be used to generate the machine code

2. COMPILATION
    takes the generated AST and compiles it into machine code
    this machine code then gets executed right away

3. EXECUTION
    execution happens in the JavaScript engines call stack
    modern JavaScript engines have optimization strategies

4. OPTIMIZATION 
    a.  create a very unoptimized version of machine code in the beginning
        so that it can start executing as fast as possible
    b.  in the background, this code is being optimized
        and recompiled during the already running program execution
    
    C.  after each optimization the unoptimized code is simply swept
        for the new more optimized code without ever stopping execution


All this parsing, compilation and optimization happens in some special threads inside the engine
that we cannot access from our code, so completely separate from the main thread 
that is basically running into call stack executing our own code.



--------------------------------------------
--------------------------------------------
    What a JavaScript runtime (like browser) is
--------------------------------------------

JavaScript runtime is like a big container with all we need to use JS:
    - JS Engine     
        Call Stack, Heap

    - Web APIs      
        more functionality which is not a part of JS like DOM, Timers, Fetch API ...

        node.js don't have Web APIs because it's the browser who provides these.
        Instead we have multiple C ++ bindings Instead we have multiple C ++ bindings.

    - Callback queue 
        data structure that contains all the callback functions that are ready to be executed

        EXAMPLE:    Like addEventListener(`click`, function) 
        When the event happens (like `click`) the callback function will be called,
        so this function is put into the callback queue and, when the call stack is empty,
        the callback function is passed to the Call Stack so that it can be executed.

        This happens by something called the event loop.
        the event loop takes callback functions from the callback queue and 
        puts them in the call stack so that they can be executed.





///////////////////////////////////////////
// execution contexts and the call stack //
///////////////////////////////////////////

After compilation we have execution.


GLOBAL EXECUTION CONTEXT 
    is created during the execution for the top-level code
    top-level is code that is not inside any function.
    (Functions should only be executed when they are called)


EXAMPLE:
const name = `Alex`;            // top level code (will be executed in global execution context)

const first = () => {           // expression function
    let a = 1;
    const b = second();
    a += b;
    return a;
}

function second() {             // declaration function
    var c = 2;
    return c;
}


EXECUTION CONTEXT
    is an abstract concept which can be defined basically as an environment
    in which a piece of JavaScript is executed.
    (It's like a box that stores all the necessary information to execute code
    like local variables, argument etc...)

    (!) JavaScript code always runs inside an execution context.
        In any JavaScript project there is only one global execution context.


After finish of executing top level code, functions starts executing.
For each and EVERY FUNCTION call a NEW EXECUTION CONTEXT will be created,
with all information need to run that function (indeed same for methods)

(!)  All these execution contexts together makes the CALL STACK.

When all functions are done executing, the engine will basically keep waiting
for callback functions to arrive so that it can execute these. 


    CREATING GLOBAL EXECUTION CONTEXT  ==>  EXECUTE TOP LEVEL CODE  ==>  EXECUTE FUNCTION AND CALLBACKS



--------------------------------------------
--------------------------------------------
    What's inside the execution context?
--------------------------------------------

Inside the execution contexts thare are:

1. Variable environment
        stores all the variables, functions and arguments object

2. Scope chain
        it basically consists of references to variables that are located outside of the current function.
        And to keep track of the scope chain, it is stored in each execution context.
        
3. `this` keyword


(!) All these content of execution context is created during the so-called
    creation phase which happens right before execution.

(!) Arrow functions DON'T have: `this` keyword and `arguments object`.
    Instead they use them from their closest regular function parent.



--------------------------------------------
--------------------------------------------
    What is the Call Stack?
--------------------------------------------

The Call Stack is basically a place where execution contexts get stacked on top of each other,
in order to keep track of where we are in the programs execution.

In easy word the call stack is like a map with order of what should be executed.





///////////////////////////////
// scope and the scope chain //
///////////////////////////////


SCOPING
    controls how our program's variables are organized and accessed by the JavaScript engine.
    like "where we can access the certain variable and where not?"

In JS we have "lexical scoping".
Lexical scoping means that the way variables are organized and accessed
    is entirely controlled by the placement of functions and of blocks in the programs code.

SCOPE
    is the space or environment in which a certain variable is declared.


SCOPE OF A VARIABLE 
    is the region of our code where a ceratin variable can be accessed.


SCOPE can be:
    1. global scope
        top level code outsude of any function or block {}
        it's accessible everywhere

    2. function scope (local scope)
        each function create this scope
        the variables are accessible fron this functions
        so these variables are NOT acceessible outside of the function

    3. block scope
        blocks {} creates own scopes since ES6
        variables are accessible only inside block
        this apllies only to `let` and `const` variables
        `var` variable is still accessible outside the block scope
        Since ES6 all function are also block scoped (only in `strict mode`)


(!) SCOPE CHAIN
    The variables which are not declared in the current scope will be
    searched in the parent scope, but never in child or siblings scopes!
    This process is called `variable lookup`.



--------------------------------------------
--------------------------------------------
    Scope Chain  VS.  Call Stack
--------------------------------------------

The scope chain has nothing to do with the order of the execution contexts in the call stack.
The scope chain does get the variable environments from the execution context
The order of function calls is not relevant to the scope chain at all.





//////////////////////////
// hoisting and the TDZ //
//////////////////////////


HOISTING
    mechanism that make some types of variables accessible in code
    before thay are declared.
    (like the variables are lifted to the top of their scope)


Before the execution, the code is scanned for variable declarations, and for each variable,
a new property is created in the variable environment object.

OBJECT                              HOISTED?                INITIAL VALUE           SCOPE

function declaration                    YES                 actual function         Block       <- ok with strict mode
var variables                           YES                 undefinded              function
let and const variables                 NO                  uninitialized, TDZ      Block
func. expression and arrow                 depends how they are declared: var or let/const



(!) when we try to access a var variable before it's declared in a code don't get the declared value
    but we get undefined. This is a really weird behavior, we might expect that we simply get an error
    or get the value, but we will get undefined. This is a common source of bugs in JavaScript.
    This is one of the main reasons why in modern JavaScript we almost never use var.


    Technically let and const variables are hosted but their initial value is uninitialized, TDZ
    TDZ = Temporal Dead Zone, it's where we can't access the variables between the 
            beginning of the scope and the place where the variables are declared.
    
    TDZ helps to catch and avoid error. For this reason it was introduced in ES6.

    Also let and const don't create properties in `window` object
    var creates properties in window object and that can have some implications in some cases.







//////////////////////
// The this keyword //
//////////////////////


this keyword/variable: 
    Special variable that is created for every execution context (every function). 
    Takes the value of (points to) the “owner” of the function in which the this keyword is used.
    (So `this` takes the value of object who is calling the method with `this` keyword.)


Diffent ways in which the function can be called:
    Method                  ->  this = <Object that is calling the method>
    Simple function Call    ->  this = `undefined` (in strict mode! Otherwise: window (in the browser))
    Arrow functions         ->  this = <this of parent scope (lexical this)> becasue arrow don't have `this`
    Event EventListener     ->  this = <DOM element that the handler is attached to>
    new, call, apply, bind  ->  info below in the JS Notes ...

    (!) this does NOT point to the function itself, and also NOT the its variable environment!







//////////////////////////////////////////
// Regular functions vs Arrow functions //
//////////////////////////////////////////


EXAMPLE:
const alex = {
  fistName: `Alex`,
  year: 1996,

  calcAge: function () {
    console.log(this);
    console.log(2023 - this.year);

    // 1st Solution (legacy)
    // we're declaring a simple function and when we'll call it...
    // ... simple function Call -> this = undefined; -> error
    // so the solution is to create a new variable `self` or `that` outside of the function
    // then we use self instead of this
    const self = this;
    const isMilleneal = function () {
      console.log(self.year >= 1981 && self.year <= 1996);
    };
    isMilleneal();

    // 2nd Solution (using arrow function)
    // arrow function will use this keyword of the parent so it's working
    const isHeMilleneal = () => {
      console.log(self.year >= 1981 && self.year <= 1996);
    };
    isHeMilleneal();
  },
};
alex.calcAge();



(!) arrow functions don't have `arguments` keyword
    arguments is basically an array

    const addExpression = function (a, b) {
    console.log(arguments);
    return a + b;
    };
    addExpression(5, 2, 5, 7);

    We can use a loop to run iterate on all elements of this arguments array
    In this way we can specify different number of arguments and still use function.







/////////////////////////////////////////////////////////
// Primitive vs Objects (Primitive vs Reference Types) //
/////////////////////////////////////////////////////////


Primitive Data Types are numbers, string, boolean, undefined, null, symbol and bigInt.
Everything else (not primitive data types) are basically objects.

When we talk about memory management we call:
    - primitive types   ->  Primitive Data Types    -> stored in call stack
    - reference types   ->  everything else         -> stored in memory heap



--------------------------------------------
primitive types

let age = 30;
let newAge = age;
age = 31;
console.log(age); // 31
console.log(newAge); // 30


JavaScript will create a so-called unique identifier with the variable name
Then a piece of memory will be allocated to an adress and the value of this adress of memeory.
Identifier points to adress and not to the value.

So first both variables (age, newAge) points to 0001.
Then we change `age` and the variable starts pointing to 0002.
0001 is immutable! (can't be changed)

CALL STACK
ADRESS      VALUE       IDENTIFIER 
0001        30          newAge
0002        31          age



--------------------------------------------
reference types

const person1 = {
    name: `Alex`,
    age: 30
};

const person2 = person1;
person2.age = 25;

console.log(person1.age); // 25 so weird
console.log(person2.age); // 25


(!!!)
When the object `person1` is created, it's stored in the heap.
Memory heap has the memory adress and the value of this object.
But the new created object (`person1`) is not poiting to the memory address in the heap,
but it's poiting to the a new piece of memory that's created in the stack.
And this new piece of memory will then point to the object
that's in the heap by using the memory address as its value.

This is why object are called reference types.
Piece of memory in the call stack has the reference to to the piece of memeory in the heap.

(!) even if we define the `person1` variable with const
    we can actually still manipulate the object without problems
    because we're actually not changing the value in memory, it's still D30F (In this example)
    we're changing the value in the heap.
    Only primitive values are immutable.

CALL STACK
ADRESS      VALUE       IDENTIFIER 
0001        30          newAge
0002        31          age
0003        D30F        person1, person2


MEMORY HEAP
        {
D30F        name: `Alex`;
            age: 25;
        }



(!) If we really want to copy this object we can use 
    Object.assign(x, y) method
    Object.assign(x, y) merges two objects (x, y) and return a new one.

EXAMPLE:
// merging empy object with `person1` object
const newObject = Object.assign({}, person1);

(!) We still have a problem!
    object.assign() only works on the first level.
    if we have an object inside the object,
    then this inner object will actually still be the same.
    So, it will still point to the same place in memory.

    EXAMPLE TO PROVE THIS:
    const sara = {
    firstName: `Sara`,
    lastName: `Cattaneo`,
    age: 27,
    family: [`Mattia`, `Paola`], // nested array (object)
    };

    const saraMarried = Object.assign({}, sara);
    saraMarried.lastName = `Bonini`;
    saraMarried.family.push(`Fabio`);

    console.log(saraMarried.family);
    console.log(sara.family); // changed like saraMarried even after copying

    To solve this we need to use libraries like  `LoDash`
 





___________________________________________________________________________________________________________________________________
05. DATA STRUCTURES, MODERN OPERATORS AND STRINGS







//////////////////////////
// Destructuring Arrays //
//////////////////////////


Destructuring = unpacking values from an array or an object to the separe variables.
                The original array is of course not affected.
                It's an ES6 feature.

--------------------------------------------
basic destructuring of an array

const arrayExample = [1, 4, 6, 7];
// here we don't need arrayExample[2] so we just leave a hole in the middle
const [a, b, , d] = arrayExample;
console.log(a, b, d); 
// output: 1 4  7              


--------------------------------------------
destructuring of a nested array

const nestedArray = [2, 5, 6, [4, 9]];
const [x, , y, [, z]] = nestedArray;
console.log(x, y, z);
// output: 2 6 9


--------------------------------------------
setting the default value for the variables in case they don't exist

const arrayRandomLenght = [8, 9];
const [p = 1, q = 1, r = 1] = arrayRandomLenght;
console.log(p, q, r);
// output:  8 9 1


--------------------------------------------
recieving and returing values from a function  +  reassigning the values

const restaurant = {
  categories: [`Italian`, `Pizzeria`, `Vegan`],
  starterMenu: [`Focaccia`, `Bruschetta`, `Caprese`, `salat`],
  mainMenu: [`Pizza`, `Carbonara`, `Risotto`, `Lasagna`],

  order: function (indexStarterMenu, indexMainMenu) {
    // returning array
    return [this.starterMenu[indexStarterMenu], this.mainMenu[indexMainMenu]];
  },
};

// recieve and return values from a function
const [starterDish, mainDish] = restaurant.order(1, 2);
console.log(starterDish, mainDish);
// output: Bruschetta Risotto

// reassigning the values without creating a temporary variable using destructuring
let [mainCategory, , secondaryCategory] = restaurant.categories;
// output:  mainCategory === italian, secondaryCategory === vegan
[mainCategory, secondaryCategory] = [secondaryCategory, mainCategory];
// output:  mainCategory === vegan, secondaryCategory === Italian
console.log(mainCategory, secondaryCategory);







///////////////////////////
// Destructuring Objects //
///////////////////////////


To destructure objects we use the curly braces {}.
Then we need to provide variable names that EXACTLY match the property
that we want to retrieve from the object.

Since in an object the order of elements doesn't matter,
we don't need to manually skip elements like in array.


--------------------------------------------
(!) EXAMPLE FOR BELOW EXPLAINING:

const restaurant = {
  categories: [`Italian`, `Pizzeria`, `Vegan`],
  starterMenu: [`Focaccia`, `Bruschetta`, `Caprese`, `salat`],
  mainMenu: [`Pizza`, `Carbonara`, `Risotto`, `Lasagna`],

  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0,
      close: 24,
    },
  },

  // pass-in and destructure the object parameter to get 4 variables (use exact name property)
  orderDelivery: function ({
    starterMenuIndex,
    mainMenuIndex,
    address,
    time = `19:00`,
  }) {
    console.log(
      `Order Recieved! ${this.starterMenu[starterMenuIndex]} and ${this.mainMenu[mainMenuIndex]} will be delivered to ${address} at ${time}`
    );
  },
};


--------------------------------------------
    basic destructuring of an object

const { categories, openingHours } = restaurant;
console.log(categories, openingHours);


--------------------------------------------
    if we want change variable names

const { categories: categoryVariable, openingHours: hours } = restaurant;
console.log(categoryVariable, hours);


--------------------------------------------
    put default values if proprety doesn't exist (in these cases just empty arrays)
    without default value we get undefined if the proprety doesn't exist

const { menu = [], starterMenu: starters = [] } = restaurant;


--------------------------------------------
    mutating variables while destructuring objects

const objectExample = {
  a: 23,
  b: 9,
  c: 28,
};
let a = 100;
let b = 200;

this DOESN'T work: {a, b} = objectExample;
if we start line with {} then JavaScript expects a code block
but we can't assign anything to a code block so we should put everything in ()

({ a, b } = objectExample);
console.log(a, b);
// output:  23 9


--------------------------------------------
    destructuring nested objects

const openHours = {
  thu: {
    open: 12,
    close: 22,
  },
  fri: {
    open: 11,
    close: 23,
  },
  sat: {
    open: 0,
    close: 24,
  },
};

// const {propertyName: {nestedPropertyName1, nestedPropertyName2}} = object;
const {
  fri: { open, close: closingHours = 24 },
} = openHours;
console.log(open, closingHours);


--------------------------------------------
    pass-in and destructure the object parameter inside a method to get variables (use exact name property)

So many times in JavaScript, we have functions with a lot of parameters.
It can be hard to know the order of parameters for someone using the function
so instead of defining the parameters manually
we can just pass an object into the function as an argument
and the function will then immediately destructure that object
calling orderDelivery() with object as parameter

restaurant.orderDelivery({
  // don't passing `time` property because we take default value in this example
  address: `Via San Casio, 25`,
  starterMenuIndex: 2,
  mainMenuIndex: 0,
});

//  orderDelivery(object) is a method coming from `restaurant` object







///////////////////////////////
// The spread operator (...) //
///////////////////////////////


spread operator
    exists since ES6
    expand an iterable into all its elements (unpacking all the elements at one)
    don't change the original iterable
    since 2018 also works with objects
    usually used on the right side of =

iterables: arrays, strings, maps, sets (NOT objects)

Useful:
    - when need to expand an array
    - when we pass arguments into functions
    - to merge iterables
    - create shallow copies of iterables and objects


(!) spread operator is similar to destructuring
    but the big difference is that the spread operator
    takes ALL the elements and DOESN'T create new variables.

    So we can only use it in places where we would otherwise 
    write values separated by commas.


--------------------------------------------
    basic syntax of spread opera

const arrayExample = [2, 7, 3];
const newArray = [1, ...arrayExample, 9];
console.log(newArray);
// output: [1, 2, 7, 3, 9]


--------------------------------------------
    we can expand an array without making a new one

console.log(...newArray);
// output: 1 2 7 3 9


--------------------------------------------
    copy array

const newArrayCopy = [...newArray];


--------------------------------------------
    join arrays

const joinedArrays = [...newArray, ...arrayExample];


--------------------------------------------
    real world examples

const restaurant = {
  categories: [`Italian`, `Pizzeria`, `Vegan`],
  starterMenu: [`Focaccia`, `Bruschetta`, `Caprese`, `salat`],
  mainMenu: [`Pizza`, `Carbonara`, `Risotto`, `Lasagna`],

  orderPasta: function (ing1, ing2, ing3) {
    console.log(`Here there is you pasta with: ${ing1}, ${ing2} and ${ing3}`);
  },
};


(!) building an array with 3 ingredients using promt()
    then use spread operator to unpack array and pass the 
    elements as parameters into a function

const ingredients = [
  prompt(`Let's make pasta. Ingredient #1: `),
  prompt(`Ingredient #2: `),
  prompt(`Ingredient #3:`),
];
restaurant.orderPasta(...ingredients);


(!) copy an object and change it without changing the original one

const newRestaurant = { ...restaurant, foundIn: 1998 };
newRestaurant.categories = [`French`];
console.log(newRestaurant);







/////////////////////////////////
// Rest Pattern and Parameters //
/////////////////////////////////

Rest pattern has exactly the same syntax  as spread operator,
but it actually does the opposite of the spread operator.


So the rest pattern 
    is used to collect multiple elements creating an array.
    usually used on the left side of =

    It called rest because it will take the rest of the elements 
    in the destructuring assignment an put them into a new array.

    Rest collects all the array after the last variable,
    and indeed there can only ever be one rest in any destructuring assignment.


--------------------------------------------
    basic syntax

const [a, b, ...others] = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(a, b, others);
// output: 1 2 [3, 4, 5, 6, 7, 8, 9]


--------------------------------------------
    works also with functions

const addNumbers = function (...allNumbers) {
  let sum = 0;
  for (let i = 0; i < allNumbers.length; i++) {
    sum += allNumbers[i];
  }
  console.log(sum);
};

addNumbers(2, 3, 5, 6);
// output: 16

addNumbers(...[2, 3, 5, 6]);
// output: 16


--------------------------------------------
    other examples:

const restaurant = {
  categories: [`Italian`, `Pizzeria`, `Vegan`],
  starterMenu: [`Focaccia`, `Bruschetta`, `Caprese`, `salat`],
  mainMenu: [`Pizza`, `Carbonara`, `Risotto`, `Lasagna`],

  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0,
      close: 24,
    },
  },

  orderPizza: function (mainIngredient, ...otherIngredients) {
    console.log(
      `Ordering Pizza with ${mainIngredient} as main ingredient and other ingredients: ${otherIngredients}`
    );
  },
};


const [dish1, , dish2, ...otherDishes] = [
  ...restaurant.starterMenu,
  ...restaurant.mainMenu,
];
console.log(dish1, dish2, otherDishes);
// output: Focaccia Caprese ['salat', 'Pizza', 'Carbonara', 'Risotto', 'Lasagna']

// works also with objects
const { sat, ...otherDays } = restaurant.openingHours;
console.log(sat, otherDays);
// output: 2 objects


restaurant.orderPizza(`Prosciutto`, `porcini`, `cipolla`, `grana`);
// output: Ordering Pizza with Prosciutto as main ingredient and other ingredients: porcini,cipolla,grana







//////////////////////////////////
// Short Circuiting (&& and ||) //
//////////////////////////////////


&& and ||
    use any data type
    return any data type
    do short-circuiting (short circuit evaluation)



--------------------------------------------
    ||

||  returns the first TRULY value or the last one

    short-circuiting means that if the first value is a truthy value it will immediately return that first value.
    EXAMPLES:
    console.log(3 || `Alex`)                                    // 3
    console.log(`` || `Alex`);                                  // Alex
    console.log(undefined || null);                             // null
    console.log(undefined || null || `` || `Hello` || 28);      // Hello


(!) instead of using ternary operator we can use ||

    EXAMPLE:

    const guests = restaurant.numberOfGuests || 50;
    // const guests = restaurant.numberOfGuests ? restaurant.numberOfGuests : 50;
    


--------------------------------------------
    &&

&&  returns the first FALSY value or the last one

    console.log(3 && `Alex`); // Alex
    console.log(0 && `Alex`); // 0
    console.log(undefined && null); // undefined
    console.log(`hello` && 27 && `Alex` && null && 28); // null


(!) instead of using if else  we can use &&


    EXAMPLE:

    restaurant.orderPizza && restaurant.orderPizza(`mashrooms`);

    // if this nethod exists
    if (restaurant.orderPizza) {
    restaurant.orderPizza(`mashrooms`);
    }







/////////////////////////////////
// Nullish coalescing operator //
/////////////////////////////////


nullish coalescing operator
    syntax: ??
    introduced in ES2020

    works like || but works only with nullish values instead of falsy values
    nullish values are null and undefined.

    So nullish coalescing operator DOESN'T include 0 or `` like ||
    SO for nullish coalescing operator 0 or `` are NOT falsy values.
    


--------------------------------------------
    PROBLEM:

const restaurant = {};
restaurant.numberOfGuests = 0;
const guestsWrong = restaurant.numberOfGuests || 50;
console.log(guestsWrong);
// output: 50


(!) 0 is a falsy value but it's the real number of guests 
    so, if 0 is falsy, || will assign 50 to `guestsWrong` variable
    to solve this we need to use nullish coalescing operator
    


--------------------------------------------
    SOLUTION:

const restaurant = {};
restaurant.numberOfGuests = 0;
const guestCorrect = restaurant.numberOfGuests ?? 50;
console.log(guestCorrect);
// output: 0

(!) Now only if `numberOfGuests` doesn't exist or it's undefinded it will we assigned to 50.
    But if `numberOfGuests` is 0, it remains 0.







/////////////////////////////////
// Logical assignment operator //
/////////////////////////////////

Logical assignment  operator -> introduced in ES2021.

--------------------------------------------
    EXAMPLE CODE FOR EXPLANATION BELOW:

const restaurant1 = {
  name: `La Cascata`,
  numberGuest: 20,
  numberPizzaMen: 0,
};

const restaurant2 = {
  name: `La Piazza`,
  owner: `Giovanni Rossi`,
  numberGuest: 0,
};




--------------------------------------------
    OR Assignment operator

restaurant1.numberGuest ||= 10;
restaurant2.numberGuest ||= 10;
//  Same as:
//  restaurant1.numberGuest = restaurant1.numberGuest || 10;
//  restaurant2.numberGuest = restaurant2.numberGuest || 10;

console.log(restaurant1.numberGuest); // 20
console.log(restaurant2.numberGuest); // 10


--------------------------------------------
    logical nullish assignment operator (null or undefined)

restaurant1.numberPizzaMen ??= 2;
restaurant2.numberPizzaMen ??= 2;
//  Same as:  restaurant1.numberPizzaMen = restaurant1.numberPizzaMen ?? 2;

console.log(restaurant1.numberPizzaMen); // 0
console.log(restaurant2.numberPizzaMen); // 2


--------------------------------------------
    AND Assignment operator

restaurant1.owner &&= `anonymous`;
restaurant2.owner &&= `anonymous`;
//  Same as:  restaurant2.owner = restaurant1.owner && `anonymous`;

console.log(restaurant1.owner); // undefined (proprety doesn't exist)
console.log(restaurant2.owner); // anonymous (changed because proprety exists)







/////////////////////////////////////
// Looping Arrays: The for-of Loop //
/////////////////////////////////////


The for-of Loop was introduced in ES6.
This loop will automatically loop over the entire array and gives us access to the item in each iteration.
The current element of iteration will be stored in the variable.
Also we don't need to create a code block if we have only one statement here to execute.
In for-of we can still use continue and break keywords.

EXAMPLE ARRAY:
    const menu = [
    `Focaccia`,
    `Bruschetta`,
    `Caprese`,
    `salat`,
    `Pizza`,
    `Carbonara`,
    `Risotto`,
    `Lasagna`,
    ];

--------------------------------------------
    basic syntax for-of loop

// for (variable of iterable) {body};
for (const item of menu) console.log(item);


--------------------------------------------
    to get also the current index

for (const item of menu.entries()) {
  // now each item is an array with index and element
  // we can access index of each of these small arrays
  console.log(`${item[0]} is index of ${item[1]} item`);
}

--------------------------------------------
    get index with modern solution

// since the item is an array when we use entries() method we can destructure it
for (const [index, element] of menu.entries()) {
  console.log(`${index} is index of ${element} item`);
}







//////////////////////////////
// Enhanced object literals //
//////////////////////////////

-   after ES6 we can compute (create) proprery name of an object putting any expression inside []
-   creating proprery with external object, we can just put variable name and nothing elements
-   writing method in a shorter way after ES6 (don't use ": function" anymore )


EXAMPLE:

const weekdays = [`mon`, `tue`, `wed`, `thu`, `fri`, `sat`, `sun`];

const openingHours = {
  // write proprety name manually before ES6                     
  thu: {
    open: 12,
    close: 22,
  },
  // after ES6 we can compute (create) proprery name                        <- (!)
  // we can put any expression inside []
  [weekdays[4]]: {
    open: 11,
    close: 23,
  },
  // example 2  -> output: day-6
  [`day-${3 + 3}`]: {
    open: 0,
    close: 24,
  },
};

const restaurant = {
  name: `La Cascata`,

  // creating proprery with external object before ES6
  openingHours: openingHours,

  // creating proprery with external object after ES6 we can just write    <- (!)
  openingHours,

  // writing method before ES6
  restaurantInfo: function () {
    console.log(this.name, this.openingHours);
  },

  // writing method after ES6 (don't use ": function" anymore )             <- (!)
  restaurantInfo2() {
    console.log(this.name, this.openingHours);
  },
};
console.log(restaurant);
restaurant.restaurantInfo2();







////////////////////////////
// Optional Chaining (?.) //
////////////////////////////

Optional Chaining
    -   introduced in ES2020
    -   works with objects, methods, arrays
    -   immediately returns undefined if a certain proprety doesn't exist
    -   checks if the proprety before ? exists 
    -   EXAMPLE:     proprety1?.property2?.property3
    

(!) Optional Chaining uses nullish concept
    PROPRETY NOT EXIST:  "null" or "undefined"
    PROPRETY EXIST:      0 or "" 


--------------------------------------------
    data for example below

const restaurant = {
  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0,
      close: 24,
    },
  },
};


--------------------------------------------
    PROBLEM AND SOLVING

// if we try to get:
console.log(restaurant.openingHours.mon);
// output: undefined  because the proprety "mon" doesn't exist


// if we don't know if the restaurant is opened on monday and we try to get "open" proprery we get error
console.log(restaurant.openingHours.mon.open);
// output: TypeError  because "undefined.open" doesn't exist


(!) to avoid this error we need to check if "restaurant.openingHours.mon" exists
    we can do it using if-else statement, but the syntax is gonna be really
    long and unreadable if we need to check the existence of different properties
    to solve this we can use optional chaining (?.) to avoid errors and get 
    undefined in case the proprety doesn't exist

// check if "openingHours" and "mon" propreties exist
console.log(restaurant.openingHours?.mon?.open);


--------------------------------------------
    Real World Example:

const weekdays = [`mon`, `tue`, `wed`, `thu`, `fri`, `sat`, `sun`];

for (const day of weekdays) {

  // since the "day" is not actual property name of the object
  // if want to use variable name as the property name we need to put it inside []
  // so now we put in variable "openingHour" the "open" or if it doesn't exist "closed"

  const openingHour = restaurant.openingHours[day]?.open ?? `closed`;
  console.log(`On ${day} the restaurant is opened at ${openingHour}`);
}


--------------------------------------------
    also works with methods, so we can check ef methods exist before we call it

console.log(restaurant.order?.(0, 4) ?? `Method doesn't exist`);


--------------------------------------------
    also works with arrays, and it checks if the array's index exists

const players = [
  { name: `Alex`, level: 31 },
  { name: `Jack`, level: 46 },
];
console.log(players[1]?.level ?? `Player doesn't exist`);







///////////////////////////////////////////////
// Looping Objects: keys, values and entries //
///////////////////////////////////////////////

Objects are not iterable but we can still loop over them in an indirect way.


--------------------------------------------
    data fot info below

const restaurant = {
  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0,
      close: 24,
    },
  },
};


--------------------------------------------
    loop over the object keys

const keys1 = Object.keys(restaurant.openingHours);
for (const i of keys1) {
  console.log(i);
  // output:  thu fri sat
}

// Object.keys(object)  ->  returns an array with keys of the Object
// with this we can do somethinbg cool:

let openStr = `We are open ${keys1.length} days: `;
for (const day of Object.keys(restaurant.openingHours)) {
  openStr += `${day}, `;
}
console.log(openStr);
// output: We are open 3 days: thu, fri, sat,


--------------------------------------------
    loop over object values

// Object.values(object)  ->  returns the actual value (not array)
const values1 = Object.values(restaurant.openingHours);
for (const i of values1) {
  console.log(i);
}


--------------------------------------------
    loop over entire object

// Object.entries(object) ->  returns an array [key, value]
const entries1 = Object.entries(restaurant.openingHours);
// destructure the array  ->  [key, value]  ->
// destructure again with exact proprety names  ->  [key, {open, close}]
for (const [key, { open, close }] of entries1) {
  console.log(`On ${key} we open at ${open} and close at ${close}`);
}
// output: On thu we open at 12 and close at 22 ...







//////////
// Sets //
//////////



Set 
    - itroduced in ES6
    - it's basically just a collection of unique values
    - can hold different data types
    - sets are also iterables
    - the order of elements in the set is irrelevant (no indexes)
    - can be empty

To create a set:
const setName = new Set(iterable)

--------------------------------------------
    Set Methods


Method	        Description

new Set()	    Creates a new Set
add()	        Adds a new element to the Set
delete()	    Removes an element from a Set
has()	        Returns true if a value exists
clear()	        Removes all elements from a Set
forEach()	    Invokes a callback for each element
values()	    Returns an Iterator with all the values in a Set
keys()	        Same as values()
entries()	    Returns an Iterator with the [value,value] pairs from a Set


Property	    Description

size	        Returns the number elements in a Set
--------------------------------------------

const orderSet = new Set([
  `pasta`,
  `pizza`,
  `pizza`,
  `risotto`,
  `pasta`,
  `pizza`,
]);

console.log(orderSet);
// output: Set(3) {'pasta', 'pizza', 'risotto'}


--------------------------------------------
    get the size of a set (return:   integer)

console.log(orderSet.size);


--------------------------------------------
    check if an element in in set (return:   true / fals)

console.log(orderSet.has(`pizza`));


--------------------------------------------
    add 1 element to the set

orderSet.add(`bread`);
console.log(orderSet);


--------------------------------------------
    delete element from a set

orderSet.delete(`pizza`);
console.log(orderSet);


--------------------------------------------
    convert from a set to an array (use spread operator)

const arrayFromASet = [...orderSet];
console.log(arrayFromASet);


--------------------------------------------
    delete all elements from the set

orderSet.clear(orderSet);
console.log(orderSet);







//////////
// Maps //
//////////


Map is a data structure that you can use to map values to keys like objects.
But, unlike objects, keys of maps can have any type (indeed also values).
Meanwhile the keys of objects are always strings.
Maps were introduced in ES6.


--------------------------------------------
    new Map()    -> create a map

const restaurant = new Map();


--------------------------------------------
    set(key, value)    -> add elements and return the updated map

restaurant.set(`name`, `La Cascata`);
restaurant.set(1, `Sondrio, via ....`);
restaurant.set(2, `Berbenno, via ....`);
console.log(restaurant);


(!) since set() method returns the updated map you can chain the set() method

restaurant
  .set(`food`, ["salat", "Pizza", "Carbonara", "Risotto", "Lasagna"])
  .set(`open`, 11)
  .set(`close`, 23)
  .set(true, `We're opened!`)
  .set(false, `We're closed!`);


--------------------------------------------
    get(key)    -> read data from the map

console.log(restaurant.get(`close`));


EXAMPLE:

const timeNow = 21;
// restaurant.get(TRUE or FALSE)
console.log(
  restaurant.get(
    timeNow > restaurant.get(`open`) && timeNow < restaurant.get(`close`)
  )
);
// output: "We're opened!"


--------------------------------------------
    has(key)    -> check if the map contains a certain key (retunr true/false)

console.log(restaurant.has(`food`));


--------------------------------------------
    delete(key) -> delete elements from the map

restaurant.delete(2);
console.log(restaurant);


--------------------------------------------
    .size property   -> returns integer of items in map

console.log(restaurant.size);


--------------------------------------------
    clear()  -> remove all elements from the map

restaurant.clear();



--------------------------------------------
    PROBLEM and SOLUTION

restaurant.set([1, 2], `test`);
console.log(restaurant.get([1, 2]));
// output: undefined

(!) we got undefined because these two arrays [1, 2] are actually NOT the same object in the heap
    to obtain the value we must insert the exact same object (key) in memory
    to make it work we need to put the array in the variable and use the variable in both places:


const arrayX = [1, 2];
restaurant.set(arrayX, `test`);
console.log(restaurant.get(arrayX));
// output: "test"


--------------------------------------------
(!) since we can use object as key we can use it in DOM elements

restaurant.set(document.querySelector(`h1`), `Heading`);
console.log(restaurant);


--------------------------------------------
    second method to create a map is to create an array witch contains multiple arrays with key:value

// const mapName = new Map([[key, value], [key, value]])
const question = new Map([
  [`question`, `What is the best language in the world?`],
  [1, `C++`],
  [2, `Ruby`],
  [3, `Python`],
  [4, `JavaScript`],
  [`correct`, 4],
  [true, `Congrats!`],
  [false, `Try again...`],
]);


--------------------------------------------
// object example for data below
const openingHoursObject = {
  thu: {
    open: 12,
    close: 22,
  },

  fri: {
    open: 11,
    close: 23,
  },
  sat: {
    open: 0,
    close: 24,
  },
};
--------------------------------------------

(!) array of arrays is exactly the same array structure that is returned from Object.entries(object)
    so we can convert objects to maps

const openingHoursMap = new Map(Object.entries(openingHoursObject));


    convert a map to an array -> get array of arrays

console.log([...question]);

// we also have the same methods of arrays:
console.log([...question.keys()]);
console.log([...question.values()]);



/////////////////////////////////


// ---EXAMPLE TO USE THE MAP---

console.log(question.get(`question`));

// since maps are iterables we can loop them
for (const [key, value] of question) {
  if (typeof key === `number`) console.log(`Answer ${key}: ${value}`);
}

// suppose the answer is got from prompt()
const answer = 4;
console.log(question.get(answer === question.get(`correct`)));







/////////////////////////////////
// Which Data Structure to Use //
/////////////////////////////////

--------------------------------------------
    sources of data

We can get data from different places like:
    1.  from the program (like status messages in source code)
    2.  from UI (user input or data written in DOM in To-do app)
    3.  from external sources (like API)


--------------------------------------------
    which data structure to use




Arrays:
    - when need ORDERED list of values with DUPLICATES
    - when need to manipulate data (there are a lot of methods)

Sets:
    - when work with UNIQUE values
    - when need hight-performance

        ----------

Objects:
    - easier to write and access (. and [])
    - when you need methods included
    - when working with JSON

Maps:
    - better performance
    - easier to iterate and to compute size
    - when simply need to map key to values
    - when need key that are not strings


--------------------------------------------

(!) There are other data structures in JS:

    Built-in:
        - WeakMap
        - WeakSet

    Not built-in:
        - stacks
        - queues
        - linked lists
        - trees
        - hash tables







//////////////////////////
// Working with strings //
//////////////////////////


Boxing
    process JS does behind the sciences which takes a string and put it 
    into a box (object) for this reason we can apply methods 
    on strings (primitive values) which are transformed to objects with the same content.
    And after operation the object is converted back to a regular string primitive.
    So all string methods return primitives!

    EXAMPLE:
    console.log(new String(`Alex`));
    // output:  object with string and all methods




(!) the following method are not changging the immutable primitive strings!
    Also these methods always return a new string
    And they are all case sensitive (uppercase/lowercase)

--------------------------------------------
    PART 1


const airLine = `TAP Air Milan`;
const airPlane = `A420`;

// you can access the index of a string
console.log(airPlane[0]); // A

// you can calculate the string length (not 0 based)
console.log(airPlane.length); // 4

// you can obtain an index of first coincidence (included)
console.log(airLine.indexOf(`Air`)); // 4

// you can obtain an index of last coincidence (included)
console.log(airLine.lastIndexOf(`i`)); // 9

// slice(start, end)  you can extract part of strings (substring)
// index of end is NOT included (start yes)
// (!)  the length of substring is always endIndex - startIndex
console.log(airLine.slice(4, 9)); // Air M

// start counting from the end by using negative index of begining counter
// so the number of negative index is also the length of how many last characters are catched
console.log(airLine.slice(-3)); // lan

/////// example of extracting the first word ///////
console.log(airLine.slice(0, airLine.indexOf(` `))); // TAP

/////// example of extracting the last word ///////
console.log(airLine.slice(airLine.lastIndexOf(` `) + 1)); // Milan


--------------------------------------------
    PART 2


// you can transform all the string to lowercase or uppercase
console.log(airLine.toLowerCase()); // tap air milan
console.log(airLine.toUpperCase()); // TAP AIR MILAN

// replace(stringToBeReplaced, newString) to change ONLY 1st coincidence parts of strings
const priceEU = `218,26€`;
const priceUS = priceEU.replace(`€`, `$`).replace(`,`, `.`);
console.log(priceUS); // 218.26$

// replaceAll(stringToBeReplaced, newString) to change ALL coincidences
console.log(`2222`.replaceAll(`2`, `3`)); // 3333
// we could use old way with regular expressions
console.log(`11111`.replace(/1/g, `3`)); // 33333



const plane = `Boeing 737 MAX`;

// includes() boolean check if there is a string inside
console.log(plane.includes(`737`)); // true

// startsWith() boolean check if string starts with that string parameter
console.log(plane.startsWith(`Boeing`)); // true

// endsWith() boolean check if string ends with that string parameter
console.log(plane.endsWith(`MAX`)); // true

/////// example of fixing the capitalization in a name ///////
const passenger = `aLeXaNder`;
const passengerLower = passenger.toLowerCase();
const passengerCorrect =
  passengerLower[0].toUpperCase() + passengerLower.slice(1);
console.log(passengerCorrect); // Alexander

/////// example of comparing an input mail to the correct mail ///////
const correctMail = `hello@gmail.com`;
const inputMail = `    Hello@GMail.com   \n`;
// trim() deletes spaces around (also trim can be only start or only end)
const normalizedMail = inputMail.toLowerCase().trim();


--------------------------------------------
    PART 3


// split()  split a string in multiple parts based on a divider string
// and it will then store the results into elements of a new array
console.log(`I'm+so+cool`.split(`+`)); // ["I'm", 'so', 'cool']

// join() join the elements of an array in a string and place parameter string between them
console.log([`Mr.`, `Alexander`, `Hamilton`].join(` `)); // Mr. Alexander Hamilton

// repaet(times) allows to repeat string multiple times
console.log(`Plese wait... `.repeat(3)); // Plese wait... Plese wait... Plese wait...



(!)  padding strings = adding characters to obtain desidered length
const testMessage = `hello`;

// padStart(totalLength, strToAdd)  adds given string to to the start until we get the desidered length
console.log(testMessage.padStart(10, `-`)); // -----hello

// padEnd(totalLength, strToAdd)    adds given string to to the end until we get the desidered length
console.log(testMessage.padEnd(10, `-`)); // hello-----

// (!)  you can chain the methods padStart() and padEnd()
console.log(testMessage.padStart(10, `-`).padEnd(15, `-`)); // -----hello-----



/////// example of function which capitalize given names ///////
const capitalizeName = function (nameStr) {
  const nameStrLower = nameStr.toLowerCase();
  const names = nameStrLower.split(` `);
  const namesCapitalized = [];
  for (const word of names) {
    namesCapitalized.push(word.replace(word[0], word[0].toUpperCase()));
  }
  console.log(namesCapitalized.join(` `));
};
capitalizeName(`alex ivanov`);
capitalizeName(`aLex ivANov`);
capitalizeName(`Alex Ivanov`);



/////// example of function which masking a piece of credit card number ///////
const maskCreditCard = function (number) {
  const numberStr = number + ``;
  const last4Digits = numberStr.slice(-4);

  console.log(last4Digits.padStart(numberStr.length, "*"));
};
maskCreditCard(12345235); // ****5235
 





___________________________________________________________________________________________________________________________________
06. A CLOSER LOOK AT THE FUNCTIONS







////////////////////////
// Default parameters //
////////////////////////

(!) default values of parameters of a function can contain any expression
    and you can also use the values of the other parameters that were set BEFORE it


--------------------------------------------
    EXAMPLE:

const bookings = [];

// setting up the defualt values for parameters inside a function (indeed can be overwrited)
const createBooking = function (flightNum, numPassengers = 1, price = 99 * numPassengers) {

  // ES5 Method:
  // numPassengers = numPassengers || 1;
  // price = price || 99;

  const booking = {
    flightNum,
    numPassengers,
    price,
  };
  console.log(booking);
  bookings.push(booking);
};

// set flightNum and numPassengers
createBooking(`MLN428`, 2);

// set flightNum and price
createBooking(`RMA364`, undefined, 76)






/////////////////////////////////////////////////////
// How passing arguments works: value vs reference //
/////////////////////////////////////////////////////


(!) JavaScript DOESN'T have passing by reference but only passing by value
    even if it looks like it's passing by reference.

Reference
    in some languages like C++ you can pass a reference to any value,
    instead of the value itself. This works even with primitives,
    so you can pass a reference to the value of 99, and then the original value,
    outside of the function, would be changed.

You pass the objects as arguments in a reference (memory address of the object).
But that reference itself is still a value that contains a memory address.
So you pass a reference to the function, but you don't pass by reference.


--------------------------------------------
    EXAMPLE:

const flight = `MLN123`;
const Alex = {
  name: `Alex Smitt`,
  passport: 123456789,
};

const checkIn = function (fligntNumber, passenger) {
  fligntNumber = `MLN999`;
  passenger.name = `Mr.` + passenger.name;
};

checkIn(flight, Alex);
console.log(flight); // didn't changed
console.log(Alex); // name is changed:  name: 'Mr.Alex Smitt'


(!) when you pass the "flight" (primitive value) as argument inside the function 
    it's gonna be a copy of original value. So "fligntNumber" contains a copy and not original value.
    like when you write:    const flightNum = flight;
    So inside the function we just changed a completely different variable and "flight" didn't changed.

    when you passed the  "Alex" object as argument inside the function,
    inside the function you changed the object: passenger.name = `Mr.` + passenger.name;
    and the original object changed too!
    Because you passed a reference type to a function, it's copied just a reference to the object in the memory heap.
    So they all pointing to the same object in memory.
    like when you write:    const passenger = Alex;






////////////////////////////////////////////
// First-class and higher-order functions //
////////////////////////////////////////////


(!) first class functions is just a concept that a programming language has or doesn't have.
    (it means is that all functions are values).

    higher order functions is not just a concept, they are real.
    and they are possible only because the language support first class functions.



JS has first class functions so:
    - JS treats functions as first-class citizens (as values)
    - functions are just another "type" of object

Since object are values, the functions are values too and you can:
    - storing them in variables or object properties
    - pass functions as arguments to other functions
    - return a function from another function
    - call function methods like bind() (methods can be called on function like a method on an object)



So since JS has first-class functions you can write higher order functions.

HIGHER ORDER FUNCTION:
    it's a function that receives another function as an argument 
    or a function that returns a new function.

    EXAMPLE:
        addEventListener    -> higher order function
        functionABC         -> callback function

        btn.addEventListener(`click`, functionABC)






///////////////////////////////////////////////
// Functions accepting the callback functions //
///////////////////////////////////////////////

Callback functions help:
    - it makes it easy to split up or code into more reusable and interconnected parts
    - it allows us to create abstraction

Abstraction
    means that we hide the detail of some code implementation because we don't really care about all that detail.
    This allows us to think about problems at a higher more abstract level (name si coming from).

    For example in the transformWord() function below this function doesn't care how the string is transformed.


--------------------------------------------
    EXAMPLE:

const eliminateSpaces = function (str) {
  return str.replaceAll(` `, ``);
};

const upperFirstLetter = function (str) {
  return str.replace(str[0], str[0].toUpperCase());
};


// high order function
const transformWord = function (str, funct) {
  console.log(`Transformed string: ${funct(str)}`);
  console.log(`Trasfomed by: ${funct.name}`);
};


const str1 = `i love JS!`;
transformWord(str1, eliminateSpaces);
transformWord(str1, upperFirstLetter);






///////////////////////////////////
// Functions returning functions //
///////////////////////////////////

(!) They are so useful if you use programming paradigm called functional programming


--------------------------------------------
    EXAMPLE:


// function returning other function
const greet = function (greetStr) {
  return function (name) {
    console.log(`${greetStr} ${name}`);
  };
};


// the result of greet() function call is a function
// store the result in the variable "greetHello" and now its value it's a function
// this works thanks to closure (difficult topic)
const greetHello = greet(`Hello`);
greetHello(`World`); // output:  Hello World


// so we can write it in a single row since "greet(`Goodmoring`)" is now has the value of function
greet(`Goodmoring`)(`everybody`);
// output:  Goodmoring everybody


// same function but wrote as Arrow Function
const greetArrow = (greetStr) => (name) => console.log(`${greetStr} ${name}`);
greetArrow(`Hi`)(`People`);
// output:  Hi People






////////////////////////////////
// The call and apply methods //
////////////////////////////////


call()  
    allows you to manually set the this keyword of any function that we want to call. 
    function.call(object_to_point_this, other_arguments_of_function)

apply()
    does the same but it doesn't recieve a list of arguments after the "this" keyword,
    but it takes an array of arguments. 
    It's an OLD WAY since you can just use the spread operator.


/////////////// data for example below ///////////////

const lufthansa = {
  airline: `Lufthansa`,
  fligthCode: `LH`,
  bookings: [],

  book(flightNumber, passengerName) {
    console.log(
      `${passengerName} booked a seat on ${this.airline} flight ${this.fligthCode}${flightNumber}`
    );
    this.bookings.push({
      flight: `${this.fligthCode}${flightNumber}`,
      name: passengerName,
    });
  },
};

const alitalia = {
  airline: `Alitalia`,
  fligthCode: `AL`,
  bookings: [],
};





// trying to call method
lufthansa.book(463, `Alexander Smith`); // Alexander Smith booked a seat on Lufthansa flight LH463
lufthansa.book(723, `Sara Cattaneo`); // Sara Cattaneo booked a seat on Lufthansa flight LH723

console.log(lufthansa.bookings);
// OUTPUT: [
//    {flight: 'LH463', name: 'Alexander Smith'},
//    {flight: 'LH723', name: 'Sara Cattaneo'}
//  ]


////////////////////////////////////////////////////////




// taking method and store it in an external function
const bookFlight = lufthansa.book;

//    PROBLEM
// bookFlight(234, `John Chan`);
// Uncaught TypeError: Cannot read properties of undefined (reading 'airline')
// now bookFlight() is not more a method but it's a regular function call,
// so the this keyword points to undefined (at least in strict mode)

//    TO FIX THIS PROBLEM WITH CALL()
// you can use:   function.call(object_point_this, all_other_arguments)
bookFlight.call(alitalia, 463, `Marco Rossi`); // Marco Rossi booked a seat on Alitalia flight AL463
bookFlight.call(lufthansa, 732, `Anna Rich`); // Anna Rich booked a seat on Lufthansa flight LH732

//    APPLY ()
const argArray = [426, `Jonas Sils`];
bookFlight.apply(alitalia, argArray); // Jonas Sils booked a seat on Alitalia flight AL426

//    modern way using spread operator
bookFlight.call(lufthansa, ...argArray); // Jonas Sils booked a seat on Lufthansa flight LH426






/////////////////////
// The bind method //
/////////////////////


// bind() is similar to the call() method but it doesn't immediately call the function
// it returns a new function where the "this" keyword is bound (set to the correct value)
// also you can bind the parameters in correct order
// partial application means that a part of the arguments of the original function are already set.
// if you don't need to specify "this" you can pass a "null" as the first argument

/////////////////// data for example below ///////////////////
const lufthansa = {
  airline: `Lufthansa`,
  fligthCode: `LH`,
  bookings: [],

  book(flightNumber, passengerName) {
    console.log(
      `${passengerName} booked a seat on ${this.airline} flight ${this.fligthCode}${flightNumber}`
    );
    this.bookings.push({
      flight: `${this.fligthCode}${flightNumber}`,
      name: passengerName,
    });
  },
};

const alitalia = {
  airline: `Alitalia`,
  fligthCode: `AL`,
  bookings: [],
};

//---------------------------------------------------------------------------------------//

const bookFlight = lufthansa.book;

const bookAlitalia = bookFlight.bind(alitalia); // returning and not calling a new function
bookAlitalia(329, `Alessia`); // Alessia booked a seat on Alitalia flight AL329

// binding the first argument "388"
const bookAlitalia388 = bookAlitalia.bind(alitalia, 388);
bookAlitalia388(`Steve`); // Steve booked a seat on Alitalia flight AL388

//---------------------------------------------------------------------------------------//

// with event listeners
lufthansa.planes = 250;
lufthansa.buyNewPlane = function () {
  this.planes++;
  console.log(this.planes);
};

// Here the "this" keyword is pointing the document.getElementById(`btn0`) which called the function
//    document.getElementById(`btn0`).addEventListener(`click`, lufthansa.buyNewPlane);
// this is the correct way with .bind(lufthansa) to point to the lufthansa object
document
  .getElementById(`btn0`)
  .addEventListener(`click`, lufthansa.buyNewPlane.bind(lufthansa));

//---------------------------------------------------------------------------------------//

// Partial Application
// here you are not interested in "this" keyword but you still use bind()

// VAT = Value-added tax
const addVAT = (rate, value) => value + value * rate;
console.log(addVAT(0.1, 100)); // 110

// set up the rate to 22%
const addVAT22 = addVAT.bind(null, 0.22);
console.log(addVAT22(100)); // 122



//---------------------------------------------------------------------------------------//
/// CHALLENGE:
//  DO THE SAME BUT WITH FUNCTION RETURNING OTHER FUNCTION

const challengeAddVAT = function (rate) {
  return function (value) {
    return value + value * rate;
  };
};

const challengeAddVAT22 = challengeAddVAT(0.22);
console.log(challengeAddVAT22(110));
//---------------------------------------------------------------------------------------//






/////////////////////////////////////////////////////
// Immediately Invoked Function Expressions (IIFE) //
/////////////////////////////////////////////////////

// You can create a function which will be executed once and then it'll dissapear.
// you need to make JS thinks it's an expression by wrapping function iside () and call it
// all data iside a scope is private (encapsulated data)
// so IIFE helps hide variables inside a local scope

// function expression
(function () {
  console.log(`This funtion runs once!`);
})();

// arrow function
(() => console.log(`Also this funtion runs once!`))();

// Variables declared with let or const create their own scope inside a block.
{
  const isPrivate = 28;
}
// console.log(isPrivate); // Uncaught ReferenceError: isPrivate is not defined
// the modern solutions prefer using this block without creating functions.
// since we can create a scope just using {}






//////////////
// Closures //
//////////////

// FORMAL DEFINITION:
// A closure is the closed-over variable environment of the execution context in which a function was created, even after that execution context is gone.

// When the outer function finishes execution, its execution context is no longer on the call stack.
// The function returned (inner) from the outer function creates a new execution context on top of the call stack.
// The variable environment of this context is empty because there are no variables declared in this function.
// Since the second function is in the global context, it is now a child scope of the global scope.
// However, any function always has access to the variable environment of the execution context in which the function was created (even after that execution context is gone).
// So, a closure is a mechanism that connects the variable environment to the function exactly as it was when the function was created.

// Closure
const secureCounting = function () {
  let person = 0;

  return function () {
    person++;
    console.log(person);
  };
};

const addPerson = secureCounting();
addPerson(); // 1
addPerson(); // 2
addPerson(); // 3

// When the addPerson() function is called, it attempts to access the "person" variable.
// Since this variable is not in the current scope, JavaScript searches for it inside the closure.
// This "search" occurs even before looking at the scope chain.
// So, even if you have a global "person" variable, the closure takes priority over the parent scopes.

// (!) Closures are created automatically, and you can't access closed-over variables directly because it's an internal property of a function.

// console.dir() displays an interactive list of the properties of the specified JavaScript object.
console.dir(addPerson);
// Now you can see all properties, including scopes with their closures.
// P.S. Everything inside the double brackets [[...]] is an internal property that you cannot access with code.



// ------------------- MORE CLOSURE EXAMPPLES ------------------- //

// EXAMPLE #1:

let z;

// function "a" which reassigns "z" when called
const a = function () {
  const num = 28;
  z = function () {
    console.log(num);
  };
};

// function "b" which reassigns "z" when called
const b = function () {
  const num = 99;
  z = function () {
    console.log(num);
  };
};

a();
z(); // 28

b();
z(); // 99

// so "z" wehn was reassigned by "b" also closed over the variable environment of "b"
// a closure can be created by reassigning functionz (even without returning them)

// EXAMPLE #2:
const boadPassengers = function (n, waitTimeSeconds) {
  // devide the passengers into 3 equal groups
  const perGroup = n / 3;

  setTimeout(function () {
    console.log(`We are boarding ${n} passengers split in ${perGroup} groups`);
  }, waitTimeSeconds * 1000);

  // the following console.log() will NOT wait for the callback, but it will be executed immediatly when called
  console.log(`We will start boarding in ${waitTimeSeconds} seconds`);
};

boadPassengers(321, 5);
// the callback function has access to the "perGroup" thanks to the closure






// ------------------- setTimeout ------------------- //
// setTimeout(a, b) accept 2 parameters:
//    a. callbackFunction
//    b. milleseconds after which callback will be executed

setTimeout(function () {
  console.log(`setTimeout Message after 3s`);
}, 3000);
// -------------------------------------------------- //











___________________________________________________________________________________________________________________________________
07. WORKING WITH ARRAYS






//////////////////////////
// Simple Array Methods //
//////////////////////////


// -------------------- ARRAY METHODS -------------------- //
/*
at()	            Returns an indexed element of an array
concat()	        Joins arrays and returns an array with the joined arrays
constructor	        Returns the function that created the Array object's prototype
copyWithin()	    Copies array elements within the array, to and from specified positions
entries()	        Returns a key/value pair Array Iteration Object
every()	            Checks if every element in an array pass a test
fill()	            Fill the elements in an array with a static value
filter()	        Creates a new array with every element in an array that pass a test
find()	            Returns the value of the first element in an array that pass a test
findIndex()	        Returns the index of the first element in an array that pass a test
flat()	            Concatenates sub-array elements 
flatMap()	        Maps all array elements and creates a new flat array
forEach()	        Calls a function for each array element
from()	            Creates an array from an object
includes()	        Check if an array contains the specified element (returns true or false)
indexOf()	        Search the array for an element and returns its position (index)
isArray()	        Checks whether an object is an array
join()	            Joins all elements of an array into a string
keys()	            Returns a Array Iteration Object, containing the keys of the original array
lastIndexOf()	    Search the array for an element, starting at the end, and returns its position
length	            Sets or returns the number of elements in an array
map()	            Creates a new array with the result of calling a function for each array element
pop()	            Removes the last element of an array, and returns that element
prototype	        Allows you to add properties and methods to an Array object
push()	            Adds new elements to the end of an array, and returns the new length
reduce()	        Reduce the values of an array to a single value (going left-to-right)
reduceRight()	    Reduce the values of an array to a single value (going right-to-left)
reverse()	        Reverses the order of the elements in an array
shift()	            Removes the first element of an array, and returns that element
slice()	            Selects a part of an array, and returns the new array
some()	            Checks if any of the elements in an array pass a test
sort()	            Sorts the elements of an array
splice()	        Adds/Removes elements from an array
toString()	        Converts an array to a string, and returns the result
unshift()	        Adds new elements to the beginning of an array, and returns the new length
valueOf()	        Returns the primitive value of an array */
// ------------------------------------------------------- //



////////////////// STAFF FROM COURSE  ///////////////////////



// ------------- Data for the examples below ------------- //
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [6, 7, 8, 9, 10];
// ------------------------------------------------------- //

// push()    adds new elements to the end of an array, and returns the new length
// unshift()    adds new elements to the beginning of an array, and returns the new length
// shift()    removes the first element of an array, and returns that element
// pop()    removes the last element of an array, and returns that element
// indexOf()    search the array for an element and returns its position (index)
// includes()    check if an array contains the specified element (returns true or false)

// slice(start, end)    returns a part of an array WITHOUT MUTATING the original one (end is NOT included)
console.log(arr1.slice(2)); // [3, 4, 5]
console.log(arr1.slice(2, 4)); // [3, 4]
console.log(arr1.slice(-2)); // [4, 5]
console.log(arr1.slice(1, -1)); // [2, 3, 4]
console.log(arr1.slice()); // [1, 2, 3, 4, 5] shallow copy (you can chain multiple methods)
console.log([...arr1]); // [1, 2, 3, 4, 5] shallow copy (does the same)

// splice(start, numberOfElementsToRemoveFromStart)    returns the extracted part of an array MUTATING the original one
console.log(arr1.splice(2, 2)); // [3, 4]
console.log(arr1); // [1, 2, 5]

// reverse()    returns the reversed array by MUTATING the original one (doesn't delete elements like splice() )
console.log(arr2.reverse()); // [10, 9, 8, 7, 6]

// array.concat(array2)    returns a new array by concatenating two arrays and WITHOUT MUTATING the original one
const numbers1 = arr1.concat(arr2);
console.log(numbers1); // [1, 2, 5, 10, 9, 8, 7, 6]
console.log([...arr1, ...arr2]); // [1, 2, 5, 10, 9, 8, 7, 6] does the same

// join(separating)    returns a string by joining all the elements of an array with separator between them
console.log(numbers1.join(` - `)); // 1 - 2 - 5 - 10 - 9 - 8 - 7 - 6






/////////////////////
// The at() method //
/////////////////////

const arr1 = [1, 2, 3, 4, 5];

// at(index)    returns the indexed element of an array
console.log(arr1.at(-1)); // 5
console.log(arr1[arr1.length - 1]); // 5
console.log(arr1.slice(-1)[0]); // 5






///////////////////////////////////////////
// Looping arrayes with forEach() method //
///////////////////////////////////////////

//    array.forEach(function(element, index, array) {....})
// loops over the array and executes the callback function on each iteration
// forEach() is a higher order function which requires a callback function
// it passes the current elements of the array as the 1st obbligatory arguments of the callback function
// you can pass also the 2nd and 3rd arugments: index of elements and the entire array
// you CAN'T break out the forEach loop


const movements = [300, -250, -150, 200, -1500, -125];



movements.forEach(function (movement) {
  if (movement > 0) {
    console.log(`You deposited ${movement}`);
  } else {
    console.log(`You withdrew ${movement}`);
  }
});
//    OUTPUT: You deposited 300   etc...



movements.forEach(function (mov, i) {
  if (mov > 0) {
    console.log(`Movement #${i + 1}: You deposited ${mov}`);
  } else {
    console.log(`Movement #${i + 1}: You withdrew ${mov}`);
  }
});
//    OUTPUT: Movement #1: You deposited 300   etc...






//////////////////////////////////////////
//  forEach() method with Maps and Sets //
//////////////////////////////////////////

// forEach() also works with maps and sets

// -------------- WITH MAPS -------------- //
const currencies = new Map([
  [`USD`, `United States Dollar`],
  [`EUR`, `Euro`],
  [`GBP`, `Pound Sterling`],
]);

// forEach(value, key, map)
currencies.forEach(function (value, key) {
  console.log(`${key} is the ${value}`);
});
//    OUTPUT: USD is the United States Dollar   etc...

// -------------- WITH SETS -------------- //

const currencyUnique = new Set([`Euro`, `USD`, `Euro`, `GBP`, `Euro`, `GBP`]);

// forEach(value, _, map)
currencyUnique.forEach(function (value, _, set) {
  console.log(`${value} is the ${value}`);
});
//    OUTPUT: Euro is the Euro   etc...

// (!)  underscore (_) passed as argument means a throwaway variable in JS (unnecessary variable)






////////////////////////////////
//  Manipulating DOM Elements //
////////////////////////////////



// -------------- innerHTML -------------- //

// innerHTML => property similar to textContent, which returns entire html (not only text like textContent)

// you can empty the entire element like container by doing this:
container.innerHTML = ``;

// you can get the html of an element by doingthis:
console.log(container.innerHTML);



// -------------- insertAdjacentHTML -------------- //

// You can create a variable containing the template literal string with HTML.
// Then you can simply "inject" this template literal inside the HTML.

// htmlElement.insertAdjacentHTML(`place`, htmlString);
//  where `place` can be:
//      - "beforebegin"     -> before the html element if it has parent
//      - "afterbegin"      -> inside the html element before the 1st child
//      - "beforeend"       -> inside the html element after the last child
//      - "afterend"        -> after the html element if it has parent

// EXAMPLE:
container.insertAdjacentHTML(`afterbegin`, htmlPiece);



// -------------- preventDefault -------------- //

// when you click submit botton of a form the page will be automatically reloded
// to prevent this you can simpy attach preventDefault() method on the event object passed as parameter in the callback

btn.addEventListener(`click`, function (event) {
    // prevent from submitting
    event.preventDefault()
})



// -------------- blur -------------- //

// to remove the focus from an html element you can call the blur() method on that element when you need that
// EXAMPLE: passwordInput.blur()




//////////////////////////////////
//  Data transformations: map() //
//////////////////////////////////


//  SYNTAX:   array.map(function(element, index, array) {...} )


// returns a new array containing all transformed elements by callback function from all original array elements
//  1. so it loops over the original array
//  2. transform the current element with the callback function,
//  3. push the transformed element to the new array
//  4. finally returns a new array with all transformed elements
// P.S. you can insert more then one "return" statement in the callback body, but only one should be executed (like in if/else)


// EXAMPLE:
// you might need to multiply each element of the original array by 2 (* 2)
// and get the new array where all elements are multiplied


// example in practice
const testArray1 = [1, 2, 3, 4, 5];
const resultArray1 = testArray1.map(function (element) {
  return element * 2;
});
console.log(resultArray1); // [2, 4, 6, 8, 10]


// same but with arraow function
const resultArray1ARROW = testArray1.map((el) => el * 2);
console.log(resultArray1ARROW); // [2, 4, 6, 8, 10]






/////////////////////////////////////
//  Data transformations: filter() //
/////////////////////////////////////

//  SYNTAX:   array.filter(function(element, index, array) {...} )

// The array.filter() method is a tool for filtering elements based on a specified test condition.
// This method returns a new array containing only the elements that pass the specified test condition defined in the callback function.
// The callback function is executed on each iteration, receiving the current element, its index, and the entire array.
// If the condition specified in the callback function after the "return" keyword evaluates to true, the current element will be included in the new filtered array.

// EXAMPLE:
// below we only need to take out only the positive numbers


// example in practice
const numbers = [200, -200, 340, -300, -20, 50, 400, -460];
const positiveNumbers = numbers.filter(function (element) {
  // return condition (true/false)
  return element > 0;
});
console.log(positiveNumbers); // [200, 340, 50, 400]







/////////////////////////////////////
//  Data transformations: reduce() //
/////////////////////////////////////

//  SYNTAX:   array.reduce(callback, initialValueAccumulator);
//            array.reduce(function(accumulator, currentElement, index, array) {...}, initialValueAccumulator);

// returns a single value by "reducing" all array elements
// so it loops over the elements, transform them to obtain only value (accumulator)
// Indeed the callback function is executed every iteration
// In each iteration you have to return the updated accumulator

// EXAMPLE:
// you might need to add all elements together


// example in practice
const moneyMovement = [200, -200, 340, -300, -20, 50, 400, -460];
const moneyBalance = moneyMovement.reduce(function (accumulator, current) {
  return accumulator + current;
}, 0);
console.log(moneyBalance); // 10



// same but with arrow func syntax
const moneyBalanceArrow = moneyMovement.reduce(
  (accum, current) => accum + current,
  0
);
console.log(moneyBalanceArrow); // 10




// EXAMPLE of finding the maximum value
const maxMovement = moneyMovement.reduce((accum, current) => {
  if (accum > current) return accum;
  else return current;
}, moneyMovement[0]);
console.log(maxMovement); // 400







//////////////////////////////////
// Data transformations: find() //
//////////////////////////////////

// SYNTAX:  array.find(callback, thisValue)
//          array.find(function (element, index, array), thisValue)

// The find() method loops over an array and retrieves the first element that satisfies a given condition.
// This method requires a callback function that should return a boolean. If true, the method returns that element.
// The callback function can optionally accept three parameters: the current element, its index, and the entire array.
// Note: If no values satisfy the testing function, undefined is returned.
// Additionally, the second argument of find() allows you to specify the value of the "this" keyword during execution.

// EXAMPLE #1:
// find the 1st negative value
const arrayMovements = [200, 450, -400, 3000, -650, -130, 70, 1300];
const firstNegativeValue = arrayMovements.find(function (el) {
  return el < 0;
});
console.log(firstNegativeValue);

// EXAMPLE #2:
// find an account
const account = accounts.find(el => el.owner === `Alexander Ivanov`);
console.log(account);
// {owner: 'Alexander Ivanov', movements: Array(5), interestRate: 1.2, pin: 1111, username: 'ai'}




////////////////////////////////////////
//  Data transformations: findIndex() //
////////////////////////////////////////


// SYNTAX:  array.findIndex(callback, thisValue)
//          array.findIndex(callback(element, index, array), thisValue)

// The array.findIndex() method requires a callback function that should return a boolean.
// If returned boolean is true, the findIndex() method returns the index of that element.
// The callback function can optionally accept three parameters: the current element, its index, and the entire array.
// Note: If no values satisfy the testing function, the method returns -1.
// Additionally, the second argument of findIndex() allows you to specify the value of the "this" keyword during execution.



const testArrey = [5, 10, 15, 20, 25, 30];


const resultIndex = testArrey.findIndex(function (el) {
  return el / 5 === 5;
});
console.log(resultIndex); // 4



// same but using arrow function syntax
const resultIndexArrow = testArrey.findIndex(el => el / 5 === 5);
console.log(resultIndexArrow); // 4




///////////////////////////////////////////////
//  Data transformations: some() and every() //
///////////////////////////////////////////////

const movements = [
  500, -200, 1000, -300, -400, 49, 700, 300, -800, 1200, -500, -1000, 1500,
];




// SYNTAX:  array.some(callbackFn, thisValue)
//          array.some(function (element, index, array), thisValue)
// some() returns "true" if at least one element of the array passes the test in the callback function
// some() method doesn't mutate the array

// EXAMPLE: check if there is a positive number bigger than 1000
const booleanResult1 = movements.some(el => el > 1000);
console.log(booleanResult1); // true



// ------------------------------------------------------- //



// NOTE:  you can check for equality (without condition) using includes() method
//        so includes() returns true if there is the exact same value inside the array.
// EXAMPLE:
console.log(movements.includes(1000)); // true
console.log(movements.includes(28)); // false



// ------------------------------------------------------- //



// SYNTAX:  array.every(callbackFn, thisValue)
//          array.every(function (element, index, array), thisValue)
// every() method is exactly the same as some() but it returns true only if all elements pass the condition




/////////////////////////////////////////////////
//  Data transformations: flat() and flatMap() //
/////////////////////////////////////////////////

// SYNTAX:  array.flat(depthLevel)
// flat() method returns a new flattened array (removing nested structures)
// depthLevel is an optional parameter (default is 1) which means how deep flattening should go
// "Infinity" keyword can be passed like argument which basically means "max depth"

const testArray = [1, [2, [3]], 4, 5, [[6], 7]];

// 1 level of flatting
const flatTestArray1 = testArray.flat();
console.log(flatTestArray1); // [1, 2, [3], 4, 5, [6], 7]

// 2 levels of flatting
const flatTestArray2 = testArray.flat(2);
console.log(flatTestArray2); // [1, 2, 3, 4, 5, 6, 7]

const flatTestArray3 = testArray.flat(Infinity);
console.log(flatTestArray3); // [1, 2, 3, 4, 5, 6, 7]



// ------------------------------------------------------- //



//  SYNTAX:   array.flatMap(function(element, index, array) {...}, thisValue )
// flatMap() combines flat() and map() methods which is better for the performance
// flatMap() works the same as map() but in the end it "flattens" the result by 1 level




//////////////////////////////////
// Data transformations: sort() //
//////////////////////////////////

//  SYNTAX:   array.sort(callback(a, b))
//            a = current value, b = next value (of any iteration)

// sort() method, by default (without arguments), does the sorting basing on strings from A to Z.
// So if you sort numbers, without giving a callback function with its own rules,
// it converts the numbers to the strings, sorts them (like strings in UTF-16 code units order), and reconverts them to numbers again.
// Careful, this method mutates the original array and returns the reference to the same array.

// Examples with default behavior:
const arrayLetters = [`b`, `c`, `a`, `z`, `d`, `m`];
const arrayNumbers = [-4, 135, 10, 27, -10, -9, 4];

console.log(arrayLetters.sort()); // ['a', 'b', 'c', 'd', 'm', 'z']
console.log(arrayNumbers.sort()); // [-10, -4, -9, 10, 135, 27, 4]

// ------------------------------------------------------- //



// You can change the default behavior by adding the callback function with its own rules
// sort() method keeps looping over the array applying the callback function until everything is sorted

// Rules of the callback function:
//   - If you return a negative value (like -1), then the value "a" will be placed before "b".
//   - If you return a positive value (like 1), then the value "a" will be placed after "b".
//   - If you return 0, the position remains unchanged.

// So:
//    - return < 0  -->  A, B (keep order)
//    - return > 0  -->  B, A (switch order)
//    - return 0    -->  position remains unchanged




// sort in ascending order
const ascendingArrayNumbers = arrayNumbers.sort((a, b) => {
  if (a > b) return 1;
  if (a < b) return -1;
});
console.log(ascendingArrayNumbers); // [-10, -9, -4, 4, 10, 27, 135]

// same result but with easier syntax
const ascendingArrayNumbers2 = arrayNumbers.sort((a, b) => a - b);
console.log(ascendingArrayNumbers2); // [-10, -9, -4, 4, 10, 27, 135]






///////////////////////////////////////////////////
// Data transformations: fill() and Array.from() //
///////////////////////////////////////////////////


// -------------- theory before practice -------------- //

// you can create an hard-coded array like this:
const arr1 = [1, 2, 3, 4, 5];
const arr2 = new Array(1, 2, 3, 4, 5);
console.log(arr1); // [1, 2, 3, 4, 5]
console.log(arr2); // [1, 2, 3, 4, 5]

// but if you specify only one argument (numberIndexes) in array-constructor ...
// ... JS will create an empty array with numberIndexes length
const arr3 = new Array(5);
console.log(arr3); // [empty × 5]

// Note: you CAN'T call many method on empty array like map() method



// ---------------------- fill() ---------------------- //



// SYNTAX:  array.fill(value, startIndex, endIndex)
// You can call fill() method on empty (or not) array.
// This method fills the entire array with the given value by mutating it.
// Optionally, while filling, you can pass startIndex and endIndex (not included)

const arr4 = arr3.fill(`Z`);
console.log(arr4); // ['Z', 'Z', 'Z', 'Z', 'Z']

const arr5 = arr4.fill(`A`, 1, -1);
console.log(arr5); //  ['Z', 'A', 'A', 'A', 'Z']



// ------------------- Array.from() ------------------- //



// SYNTAX:  Array.from(arrayLike)
// SYNTAX:  Array.from(arrayLike, map(), thisValueForMapFunc)
// SYNTAX:  Array.from(arrayLike, function(element, index, array) {...}, thisValueForMapFunc)

// creating a new array with Array.from(ObjectWithLengthProperty, map())
const arr6 = Array.from({ length: 5 }, () => `Y`);
console.log(arr6); // ['Y', 'Y', 'Y', 'Y', 'Y']

// same logic but adding arguments to the map() method
const arr7 = Array.from({ length: 5 }, (_, index) => index + 1);
console.log(arr7); // [1, 2, 3, 4, 5]


// So you can convert an iterable to an array by using Array.from() method.
// For example you convert a NodeList from document.querySelectorAll() to an array.
// You need to do this conversion to be able to apply array-instances methods on them.

// NOTE: from() method is used on Array Object and NOT on instances


// NOTE: also you can convert an iterable/arrayLike into an array using the spread operator
// but in this case you can't chain methods
console.log([...`HELLO`]); // ['H', 'E', 'L', 'L', 'O']











___________________________________________________________________________________________________________________________________
08. NUMBERS, DATES AND TIMERS






/////////////////////////////////////
// Converting and Checking Numbers //
/////////////////////////////////////

// In JS all numbers are presented internally as floating point numbers (no matter you write them is int or float)
// For this reason we have only one data type for all numbers (28 === 28.0 // true)
// Also numbers are stored in binary format, so it's difficul to represent some fractions (like 0.1)

console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // false

// convert a string to a number
// when JavaScript sees the plus operator, it will do type coercion.

console.log(Number(`28`)); // 28
console.log(+`28`); // 28

// NOTE:  parseInt() and parseFloat() are global functions,
//        so you can call them without Number object,
//        but for good practice you should call them on Number object like Number.parseFloat()
//        Number provides its own namespace




// ----------------- methods of Number object ----------------- //



//    Number.parseInt(str, radix)
// returns an integer number from a string which has to start with a number or space (can include symbols)
// optionally you can (and should) specify the 2nd argument (radix) which is  the base of the numeral system (10, 2 which binary etc)
console.log(Number.parseInt(`2rem`, 10)); // 2
console.log(Number.parseInt(`2.5rem`, 10)); // 2
console.log(Number.parseInt(`rem20`, 10)); // NaN


//    Number.parseFloat(str)
// returns an floating point number from a string which has to start with a number or space (can include symbols)
console.log(Number.parseFloat(`2.5rem`)); // 2.5


//    Number.isNaN(value)
// returns true if the given value is NaN (not a number)
console.log(Number.isNaN(20)); // false
console.log(Number.isNaN(+`20rem`)); // true
console.log(Number.isNaN(10 / 0)); // false (because 10 / 0 = Infinity)


//    Number.isFinite(value)
// returns true if the given value is a finite number (NaN and Infinity are false!)
// it's the best method to check if the value is a real number
console.log(Number.isFinite(28)); // true
console.log(Number.isFinite(28.1)); // true
console.log(Number.isFinite(0)); // true
console.log(Number.isFinite(`28`)); // false


//    Number.isInteger(value)
// returns true if the given value is an Integer
console.log(Number.isInteger(28)); // true
console.log(Number.isInteger(28.0)); // true
console.log(Number.isInteger(28.1)); // false
console.log(Number.isInteger(`28`)); // false






///////////////////////
// Math and Rounding //
///////////////////////

___________________________________________________________________________
// function which creates a random number between MIN and MAX
const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
___________________________________________________________________________


//    Math.sqrt(number)
// returns the square root of the given value
// same result:   number ** (1 / 2)
console.log(Math.sqrt(25)); // 5
console.log(25 ** (1 / 2)); // 5
console.log(8 ** (1 / 3)); // 2 (cubic root)

//    Math.max(value1, value2, value3...)
// return the max value of the given values
// it does type coercion, but it doesn't parsing
console.log(Math.max(1, 2, 3, 4, 5, 6, 6.2)); // 6.2
console.log(Math.max(1, 2, 3, 4, `5`)); // 5
console.log(Math.max(1, 2, 3, 4, `5px`)); // NaN

//    Math.min(value1, value2, value3...)
// return the min value of the given values
// it does type coercion, but it doesn't parsing
console.log(Math.min(1.2, 2, 3, 4, 5)); // 1.2
console.log(Math.min(`1`, 2, 3, 4, 5)); // 1
console.log(Math.min(`px`, 2, 3, 4, 5)); // NaN

// there are different constants on Math Object like PI
console.log(Math.PI); // 3.141592653589793

//    Math.random()         returns a random number between 0-1
//    Math.trunc(number)    removes the decimal part
console.log(Math.trunc(Math.random() * 10)); // returns a random number between 0 and 9
console.log(Math.trunc(Math.random() * 10) + 1); // returns a random number between 1 and 10

// function which creates a random number between MIN and MAX
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1)) + min;

//    Math.trunc(num)
// removes any decimal part (only removing)
console.log(Math.trunc(28.753)); // 28
console.log(Math.trunc(-28.3)); // - 28

//    Math.round(num)
// rounds to the NEAREST integer indeed removing decimal part
console.log(Math.round(28.2)); // 28
console.log(Math.round(28.8)); // 29

//    Math.ceil(num)
// rounds up to the BIGGER integer indeed removing decimal part
console.log(Math.ceil(28.1)); // 29
console.log(Math.ceil(28.8)); // 29

//    Math.floor(num)
// rounds down to the LOWER integer indeed removing decimal part
console.log(Math.floor(28.1)); // 28
console.log(Math.floor(28.8)); // 28
console.log(Math.floor(-28.3)); // - 29

// NOTE:  all these methods also do the type coercion

console.log(`---------------CONTINUE HERE---------------`);

//    (number).toFixed(x)
// RETURNS STRING, round and show x decimal parts of the number
console.log((28).toFixed(2)); // "28.00"
console.log((28.128).toFixed(2)); // "28.13"
console.log((2.1).toFixed()); // "2"
console.log((2.1).toFixed(2)); // "2.10"
console.log((2.8).toFixed()); // "3"

// to return a number with .toFixed()
console.log(+(28.128).toFixed(2)); // 28.13
console.log(+(28.345).toFixed(2)); // 28.34






////////////////////////////
// The remainder operator //
////////////////////////////

// The remainder operator returns a remainder of a divison.
// For example:
//  - if you divide 5 / 2 you get 2.5
//  - if you leave the decimal part, only 2 remains (from 2.5)
//  - now if you multiply your result (2) to the number of divison (2) you get 4 (2*2=4)
//  - then if you subtruct the result (4) from the originl number (5) you get 1 (5-4=1)
//  - and this 1 is the remainer

console.log(5 % 2); // 1 (5 = 2 * 2 + 1 remainder)
console.log(8 % 3); // 2 (8 = 3 * 2 + 2 remainder)
console.log(13 % 3); // 1 (13 = 4 * 3 + 1 remainder)

// you can use this to check if the number is even (because even % 2 = 0)
// with knowledge if the number is even or odd you can do different things

// PRACTICAL EXAMPLE:

// 1. attach an event listener to the "labelBalance" element
// 2. create a NodeList with all elements with "movements__row" class
// 3. transform it into an array usign the spread operator
// 4. check if the current element is even and apply some style on it
// 5.  apply some style on every 3rd index element

labelBalance.addEventListener(`click`, function (e) {
  e.preventDefault();
  [...document.querySelectorAll(`.movements__row`)].forEach(function (el, i) {
    // 0, 2, 4, 6...
    if (i % 2 === 0) {
      el.style.backgroundColor = `#c7c5bf`;
    } // 0, 3, 6, 9
    else if (i % 3 == 0) {
      el.style.backgroundColor = `#8c8a85`;
    }
  });
});






////////////////////////
// Numeric separators //
////////////////////////

// Numeric separator is ES2021 feature
// Numeric separators are simply underscores that you can place anywhere you want between numbers (only 1 in a row)
// It helps you understand the number and these underscores are ignored by hte JS engine.
// Without NS: 836269063348
// With NS: 836_269_063_348

// NOTE: you can't use it in strings before converting the str in a numbers (JS can't use parsing on them)
console.log(Number(`256_000`)); // NaN






/////////////////////////
// Working with BigInt //
/////////////////////////

// Big Integer is a special data type of Integers that was introduced in 2020.
// since in JS the numbers are stored in binary system based on 64 digits we have some limits
// this is the biggest int that JS can represent safely:
console.log(2 ** 53 - 1); // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
// 2 because it's binary
// 53 because there are 53 bits to store the number (the rest of digits are used to store position of decimal point and the sign)

// to transform a really big number into BigInt you can just put "n" in the end of number (hardcode)
// or use BigInt() function with small numbers (safe numbers) and it's usually used to not mix data types.
console.log(231782351283375123n); // 231782351283375123n

// all the operator works the same (but remember that you can't mix BigInt with Numbers)
console.log(25n + 5n); // 30n

// EXCEPTION:
// comparison operators (20n === 20 is false)
// plus operator when working with strings

// Also Math operations are not working with BigInt
// And when you devide bigint the bigint is returned cutting out the decimal part:
console.log(10n / 3n); // 3n






////////////////////
// Creating dates //
////////////////////

// There are 4 WAYS to create a date (because new Date() constructor function accepts different parameters)

// ------------------------------------------------------- //

//  ---> 1). use "new Date()" constructor to obtain the "now" moment

const now = new Date();
console.log(now); // Sun Nov 26 2023 15:51:49 GMT+0100 (Ora standard dell’Europa centrale)

// ------------------------------------------------------- //

//  ---> 2). parse the date from a date string made my constructor (good idea)

const date1 = new Date(`Nov 26 2023 15:54:29`);
console.log(date1); // Sun Nov 26 2023 15:54:29 GMT+0100 (Ora standard dell’Europa centrale)

// ------------------------------------------------------- //

//  ---> 3). write the string manually (not a good idea)

const date2 = new Date(`August 28 1996`);
console.log(date2); // Wed Aug 28 1996 00:00:00 GMT+0200 (Ora legale dell’Europa centrale)

// new Date(year, month, weekDay, hour, minute, second) where january is 0
const date3 = new Date(2025, 7, 28);
console.log(date3); // Thu Aug 28 2025 00:00:00 GMT+0200 (Ora legale dell’Europa centrale)

const date4 = new Date(2025, 0, 40); // January 40th??? It's ok...
console.log(date4); // Sun Feb 09 2025 00:00:00 GMT+0100 (Ora standard dell’Europa centrale)

// ------------------------------------------------------- //

//  ---> 4). new Date(unixTimestampMilliseconds) SECONDS SINCE JAN 01 1970 * 1000

const date5 = new Date(1000);
console.log(date5); // Thu Jan 01 1970 01:00:01 GMT+0100 (Ora standard dell’Europa centrale)

// create date 3 days after the epoch. (3days * 24hours * 60minutes * 60seconds *1000milliseconds)
const date6 = new Date(3 * 24 * 60 * 60 * 1000);
console.log(date6); // Sun Jan 04 1970 01:00:00 GMT+0100 (Ora standard dell’Europa centrale)

const date6Timestamp = 3 * 24 * 60 * 60 * 1000;
console.log(date6Timestamp); // 259200000

// ------------------------------------------------------- //

// ----------------------- methods ----------------------- //

const futureDate = new Date(2025, 7, 28, 10, 30);
console.log(futureDate); // Thu Aug 28 2025 10:30:00 GMT+0200

// date.getFullYear()    returns year ( never use getYear()!! )
console.log(futureDate.getFullYear()); // 2025

// date.getMonth()    returns month
console.log(futureDate.getMonth()); // 7 (august is 7 ZERO BASED)

// date.getDate()    returns day of month
console.log(futureDate.getDate()); // 28

// date.getDay()    returns day of the week
console.log(futureDate.getDay()); // 4 (0 IS SUNDAY)

// date.getHours()    returns hours
console.log(futureDate.getHours()); // 10

// date.getMinutes()    returns mniutes
console.log(futureDate.getMinutes()); // 30

// date.getSeconds()    returns seconds
console.log(futureDate.getSeconds()); // 0

// date.getMilliseconds()    returns milliseconds
console.log(futureDate.getMilliseconds()); // 0

// date.toISOString()    returns ISO string (international standard)
// "Z" in the ends means "UTC": Coordinated Universal Time (time without any time zone in London and without daylight savings)
console.log(futureDate.toISOString()); // 2025-08-28T08:30:00.000Z

// date.getTime()    returns timestamp (milliseconds passed since January 1, 1970)
console.log(futureDate.getTime()); // 1756369800000

// Date.now()    retuns current timestamp (now exact moment)
console.log(Date.now()); // 1701012829399

// (!) NOTE: also there "set" version for previous methods
// EXAMPLE:
futureDate.setYear(2030);
console.log(futureDate); // Wed Aug 28 2030 10:30:00 GMT+0200






///////////////////////////
// Operations with dates //
///////////////////////////

// creating 2 dates and get only the timestamp (number data type)
const data1 = new Date(2023, 10, 25).getTime();
const data2 = new Date(2023, 10, 20).getTime();

// function which returns difference of days
const calcDaysPassed = (date1, date2) =>
  Math.round(Math.abs(date2 - date1) / (1000 * 60 * 60 * 24));

// testing function "calcDaysPassed"
console.log(calcDaysPassed(data1, data2)); // 5

// NOTE: 
// you can just use date library "moment.js" if you need precicly calculations on dates






/////////////////////////////////////
// Internationalizing dates (INTL) //
/////////////////////////////////////

// JS has a new Internationalization API called "INTL"
// It helps you to easily format numbers and strings according to different languages.

// So, INTL namespace object contains several constructors.
// One of the constuctor functions is Intl.DateTimeFormat() to work with dates

// Intl Docs:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl
// Intl.DateTimeFormat Docs:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat
// All options:               https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat

// SYNTAX:

// Intl.DateTimeFormat(localStr, options)                 --> returns formatter
// Intl.DateTimeFormat(localStr, options).format(date)    --> returns date in string formatted for the given country
//    `localStr` is the language-country (like `en-US`)
//    `options` is optional argument which expects a configuratiopn object with parameters

// You can get the `localStr` from user's browser:
const locale = navigator.language;
console.log(locale); // it-IT
// NOTE: also you can pass `undefined` in `localStr` to use the browser's default locale

// ----------------------- EXAMPLES ----------------------- //

const now = new Date();
console.log(now); // Tue Nov 28 2023 15:47:42 GMT+0100

const dateV0 = Intl.DateTimeFormat(`en-US`).format(now);
console.log(dateV0); // 11/28/2023 (USA format without options so with default configuration)

// -------------------------------------------------------- //

const options1 = {
  hour: `numeric`,
  minute: `numeric`,
};

const dateV1 = Intl.DateTimeFormat(`en-US`, options1).format(now);
console.log(dateV1); // 4:06 PM (shows only what is provided by options)

// -------------------------------------------------------- //

const options2 = {
  hour: `numeric`,
  minute: `numeric`,
  seconds: `numeric`,
  day: `numeric`,
  month: `long`,
  year: `numeric`,
  weekday: `long`,
};

const dateV2UK = Intl.DateTimeFormat(`en-UK`, options2).format(now);
console.log(dateV2UK); // Tuesday, 28 November 2023 at 16:13

const dateV2RU = Intl.DateTimeFormat(`ru-RU`, options2).format(now);
console.log(dateV2RU); // вторник, 28 ноября 2023 г. в 16:14

// -------------------------------------------------------- //






///////////////////////////////////////
// Internationalizing numbers (INTL) //
///////////////////////////////////////

// SYNTAX:    Intl.NumberFormat(localStr, options).format(yourNumber)
//    `localStr` is the language-country (like `en-US`)
//    `options` is optional argument which expects a configuratiopn object with parameters

// More:    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat

/*
OPTIONS ={
  style: "decimal/unit/percent/currency",
  unit: "mile-per-hour/kilometer-per-hour/celsius/liter....",
  unitDisplay: "long",
  currency: "EUR/JPY/",
  ALL OPTIONS:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
}
*/

// You can get the `localStr` from user's browser:
const locale = navigator.language;
console.log(locale); // it-IT
// NOTE: also you can pass `undefined` in `localStr` to use the browser's default locale

// ----------------------- EXAMPLES ----------------------- //

const randomNumber = 387403.23;

// -------------------------------------------------------- //

console.log(Intl.NumberFormat(`en-US`).format(randomNumber)); // 387,403.23
console.log(Intl.NumberFormat(`it-IT`).format(randomNumber)); // 387.403,23
console.log(Intl.NumberFormat(`ru-RU`).format(randomNumber)); // 387 403,23

// -------------------------------------------------------- //

const options1 = {
  style: `unit`,
  unit: `mile-per-hour`,
};

console.log(Intl.NumberFormat(`en-US`, options1).format(randomNumber)); // 387,403.23 mph
console.log(Intl.NumberFormat(`it-IT`, options1).format(randomNumber)); // 387.403,23 mi/h
console.log(Intl.NumberFormat(`ru-RU`, options1).format(randomNumber)); // 387 403,23 ми/ч

// -------------------------------------------------------- //

const options2 = {
  style: `unit`,
  unit: `celsius`,
};

console.log(Intl.NumberFormat(`en-US`, options2).format(randomNumber)); // 387,403.23°C
console.log(Intl.NumberFormat(`it-IT`, options2).format(randomNumber)); // 387.403,23 °C
console.log(Intl.NumberFormat(`ru-RU`, options2).format(randomNumber)); // 387 403,23 °C

// -------------------------------------------------------- //


___________________________________________________________________________

// universal function to display currency
const formatCurrency = function (value, locale, currency) {
  const options = {
    style: `currency`,
    currency: currency,
  };
  return Intl.NumberFormat(locale, options).format(value);
};
___________________________________________________________________________



// testing formatCurrency()
console.log(formatCurrency(34.23, `en-US`, `EUR`)); // €34.23






////////////////////////////////////////
// Timers: setTimeout and setInterval //
////////////////////////////////////////

// SYNTAX:        setTimeout(callback, msTime)
//                setTimeout(callback(Arg1, Arg2...), msTime, 0...)
// To cancel it:  if(condition) clearTimeout(setTimeoutName);

// setTimeout() runs once after the given time (msTime)
// Important: the code continues running without waiting for the given time (msTime)
// Optionally, pass arguments inside the callback function
// You can cancel the callback until the delay actually passes
// To cancel it, store setTimeout() inside a variable
// and pass that variable as an argument inside clearTimeout after your condition

// Simple example
setTimeout(() => console.log(`Hello`), 3 * 1000); // `Hello` (after 3 seconds)

// Example with 3 arguments
setTimeout(
  (arg1, arg2, arg3) => console.log(`Hello ${arg1}, ${arg2}, and ${arg3}`),
  3 * 1000,
  `John`,
  `Alex`,
  `Karl`
); // Hello John, Alex, and Karl

// Example of cancelling setTimeout()
const names = [`John`, `Alex`, `Karl`];
const callNames = setTimeout(
  (arg1, arg2, arg3) => console.log(`Hello ${arg1}, ${arg2}, and ${arg3}`),
  3 * 1000,
  ...names
);
if (names.includes(`Karl`)) {
  clearTimeout(callNames);
} // WILL NEVER RUN

// -------------------------------------------------------- //

// SYNTAX:        setInterval(callback, msTime)
//                setInterval(callback(Arg1, Arg2...), msTime, passInArg1, passInArg2...)
// To cancel it:  if(condition) clearInterval(setIntervalName);

// setInterval() executes the callback function forever after `msTime` until you stop it
// Important: the code continues running without waiting for the given time (msTime)
// Optionally, pass arguments inside the callback function
// You can also cancel the callback function
// To cancel it, store setInterval() inside a variable
// and pass that variable as an argument inside clearInterval after your condition

// Simple example
setInterval(() => console.log(`Hello world`), 5 * 1000); // `Hello world` (every 5 seconds)

// Example to console.log() the time after each second
setInterval(() => console.log(new Date().toISOString()), 1000); // 2023-11-28T21:33:30.743Z (every second)









___________________________________________________________________________________________________________________________________
09. ADVANCED DOM AND EVENTS






//////////////////////////////
// How the DOM really works //
//////////////////////////////

// DOM (Document Object Model) is basically interface between browser in JS code.
// DOM allows JS interact with browser
// So the code can modify HTML elements, styles, classes, attributes, listen and respond to events
// DOM tree is generated from HTML document
// DOM is a very complex API which containt a lot of methods and properties

// All methods and properties are organized in different types of nodes.
// Each node is represented in JavaScript by an object (which has methods and properties)
// `Node` -> every single node in DOM tree is of the type node.
//      - .textContent
//      - .childNodes
//      - .parentNode
//      - .cloneNode()    etc ...

// Types of child nodes:

// 1. Text        -> <p>paragraph</p>
// 2. Comment     -> <!--comment-->
// 3. Document    -> querySelector(), createElement(), getElementById() ...
// 4. Element     -> gives html element access to many methods and properties
//                    . innerHtml
//                    .classList
//                    .children
//                    .parentElement
//                    .append()
//                    .remove()
//                    .insertAdjacentHTML()
//                    .querySelector()
//                    .closest()
//                    .matches()
//                    .scrollIntoView()
//                    .setAttribute()
//                    etc....
// 4.1.   HTMLElement
// 4.1.1  HTMLButtonElement (for each HTML element that exists in HTML)
// 4.1.2  HTMLDivElement  (each of these children element has unique properties)
// 4.1.3  etc... images, ul, li ...

// Inheritance makes everything work;
// Inheritance: means all the child types will also get access to the methods and properties of all their parent node types.

// EventTarget -> special node which is PARENT of `Node` and `Window` nodes type
//                thanks to this node and inheritance you can call addEventListener to every single type of node.






///////////////////////////////////////////////
// Selecting, creating and deleting elements //
///////////////////////////////////////////////



// ------------------- SELECTING ELEMENTS ------------------- //



// selecting the entire document, head and body:

console.log(document.documentElement);
console.log(document.head);
console.log(document.body);

// :root === document.documentElement



// other methods of selecting:

document.querySelector(`.header`); // returns the 1st element which matches the selector
document.querySelectorAll(`.section`); // returns NodeList with all elements which matches the selector
document.getElementById(`section--1`); // returns the element which matches the id
document.getElementsByTagName(`buttons`); // returns an life HTML collection with all HTML elements with type of `buttons` in this case
document.getElementsByClassName(`btn`); // return a life html collection with all elements with class of `btn`

// NOTE: `HTML collection` is a `life-collection" which means they automatically updated when DOM changes
// NOTE: `NodeList` are not automatically updated



// ------------------- CREATING ELEMENTS ------------------- //



// 1. insertAdjacentHTML

// container.insertAdjacentHTML(`afterbegin`, htmlPiece);

// You can create a variable containing the template literal string with HTML.
// Then you can simply "inject" this template literal inside the HTML.

// htmlElement.insertAdjacentHTML(`place`, htmlString);
//  where `place` can be:
//      - "beforebegin"     -> before the html element if it has parent
//      - "afterbegin"      -> inside the html element before the 1st child
//      - "beforeend"       -> inside the html element after the last child
//      - "afterend"        -> after the html element if it has parent


// -------------- //


// 2. document.createElement(HtmlTagNameStr);

const message = document.createElement(`div`);

// this method also returns A DOM element
// this element is not yet in DOM but it's stored in a variable and you can do operations on it
// (the element retur is of the same type like element returned from document.querySelector(`.header`); )
message.classList.add(`cookie-message`);
message.textContent = `We're using cookies to improve functionality`;
message.innerHTML = `We're using cookies to improve functionality <button class="btn btn--close-cookie">Got it!</button>`;


// -------------- //


// 3. prepend() append() -> actually adding this elemento to the HTML

container.prepend(message); // add message as the first child of the container
container.append(message); // add message as the last child of the container

// now this message is life element of the DOM (it CAN'T be in different places in the document)
// so in the example above it was positioned as 1st child, then moved as last child
// so you can use prepand and append to move elements


// -------------- //


// 4. cloneNode() -> copy element

container.append(message.cloneNode(true)); // add message as the last child of the container
// if argument is `true` also the child elements will be copied


// -------------- //


// 5. before() after()

// before() insert element before HTML element (not as child)
// after() insert element after HTML element (not as child)
container.before(message);



// ------------------- DELETING ELEMENTS ------------------- //



// 1. remove() -> removes element from HTML (recent element)
message.remove();

// 2. elementXX.parentElement.removeChild(elementXX); (legacy)
// before we needed to select the parent element and then remove the children
message.parentElement.removeChild(message);





  // ----------------------------------------- //
EXAMPLE OF CREATING, ADDING AND REMOVING A COOKIE DIV:
  // ----------------------------------------- //


const header = document.querySelector(`.header`);

const cookieMessageDiv = document.createElement(`div`);
cookieMessageDiv.classList.add(`cookie-message`);
cookieMessageDiv.innerHTML = `I know cookies are so sad, but we're using them to improve functionality <button class="btn btn--close-cookie">Got it!</button>`;
header.before(cookieMessageDiv);

// selecting AFTER creating
const btnCloseCookie = document.querySelector(`.btn--close-cookie`);

// EventListener close Cookies Div
btnCloseCookie.addEventListener(`click`, function () {
  cookieMessageDiv.remove();
});






////////////////////////////////////
// Styles, attributes and classes //
////////////////////////////////////



// ------------------- STYLES ------------------- //


//    element.style.camelCaseStyle = `value`
// change style property
// doing this way the styles will be places `inline`
cookieMessageDiv.style.backgroundColor = `#37383d`;
cookieMessageDiv.style.width = `120%`;


//    element.style.camelCaseStyle
// read style property ONLY set inline
console.log(cookieMessageDiv.style.width); // 120%
console.log(cookieMessageDiv.style.height); // NOTHING BECAUSE IS NOT INLINE STYLE


//    getComputedStyle(element).camelCaseStyle
// get the real style as it appears on the page (even if it's not declared)
console.log(getComputedStyle(cookieMessageDiv)); // A REALLY BIG LIST OF STYLES
console.log(getComputedStyle(cookieMessageDiv).height); // 75px


//    document.documentElement.style.setProperty(`nameOfProperty`, `newValue`)
// css variables === (css custom properties)
// change the value of a css variable
document.documentElement.style.setProperty(`--color-primary`, `#52a064`);



// EXAMPLE:
cookieMessageDiv.style.height =
  Number.parseFloat(getComputedStyle(cookieMessageDiv).height) + 30 + `px`;




// ------------------- ATTRIBUTES ------------------- //


// attributes are: src, alt, id, href, placeholder etc...
// every type of element has its own standard attributes


//    element.standardAttributeName
// get or set the value of the standard attributes
console.log(logoIMG.src); // http://127.0.0.1:5500/img/logo.png (ABSOLUTE URL)
console.log(logoIMG.alt); // Bankist logo
console.log(logoIMG.className); // nav__logo (it's className and not simply class)

logoIMG.alt = `Cool Bankist App Logo`;
console.log(logoIMG.alt); // Cool Bankist App Logo


//    element.getAttribute(`attributeName`)
// get the value of the NON standard attributes (also works with standrd)
// this method gives you RELATIVE attibutes and not ABSOLUTE (of src, href...)
console.log(logoIMG.designer); // undefined (BECAUSE IT'S NOT STANDARD PROPERTY)
console.log(logoIMG.getAttribute(`designer`)); // Jonas
console.log(logoIMG.getAttribute(`src`)); // img/logo.png


//    element.setAttribute(`attributeName`, `newValue`)
// set the value of the NON standard attributes
logoIMG.setAttribute(`designer`, `Jonas New Attribute`);
console.log(logoIMG.getAttribute(`designer`)); // Jonas New Attribute


//    element.dataset.dataAttributeName = `newValue`
// get or set data attribute from `dataSet` object
// NOTE:  there is a special type of attributes called `data attributes`
//        data attributes always starts with `data-`
//        we need to transform the name in camelcase without 1st word `data` like below
//        example: data-version-number-actual="3.0"   --> versionNumberActual
console.log(logoIMG.dataset.versionNumberActual); // 3.0




// ------------------- CLASSES ------------------- //

// element.classList.add(`className`)
// element.classList.remove(`className`)
// element.classList.toggle(`className`)
// element.classList.contains(`className`)

// this OVVERERIDE all classes (bad practice)
// element.className = `className`






///////////////////////////////////
// Implementing Smooth scrolling //
///////////////////////////////////

---------------------------------------------------------------------------------

//    element.getBoundingClientRect();
// returns `DOMRect object` which is the smallest rectangle which contains the entire element
// this object describes the position and size of the overall rectangle in pixels
// Properties (NOT width and height) are relative to the top-left of the viewport.

EXAMPLE of DOMRect object:
  bottom: 3657.1875
  height: 2384.1875
  left: 0
  right: 641
  top: 1273
  width: 641
  x: 0                -> px from left of viewport
  y: 1273             -> px from top of viewport


---------------------------------------------------------------------------------

//    window.scroll(x, y)    /    window.scroll(optionsObject)
// scroll windows to coordinates of x and y (in pixels)
// scrollTo() is the same method

options = {
  top: 100,
  left: 100,
  behavior: "smooth" / "instant" / "auto",
}


console.log(window.scrollX); // returns px of scrolling from LEFT
console.log(window.scrollY); // returns px of scrolling from TOP


---------------------------------------------------------------------------------

//    calculate viewport size
document.documentElement.clientHeight; // returns px of the viewport height
document.documentElement.clientWidth; // returns px of the viewport width

---------------------------------------------------------------------------------


// PRACTICAL EXAMPLE:

// selecting elements
const btnScrollTo = document.querySelector(`.btn--scroll-to`);
const section1 = document.getElementById(`section--1`);



btnScrollTo.addEventListener(`click`, function (event) {
  // get the coordinates of seciton1
  const seciton1Coordinates = section1.getBoundingClientRect();

  // to get the correct coordinates you need to sum:
  //  1. px from top of viewport
  //  2. current scroll position
  // like this:
  const sect1X = seciton1Coordinates.x + window.scrollX;
  const sect1Y = seciton1Coordinates.y + window.scrollY;

  // creating the object with options for scroll()
  const scrollOptions = {
    top: sect1Y,
    left: sect1X,
    behavior: `smooth`,
  };

  // scroll to the correct position
  window.scroll(scrollOptions);
});


---------------------------------------------------------------------------------
// MODERN WAY:
// element.scrollIntoView({behavior: `smooth`});
section1.scrollIntoView({ behavior: `smooth` })
---------------------------------------------------------------------------------






////////////////////////////////////////
// Types of events and event handlers //
////////////////////////////////////////

// Events:
// an event is a signal generated by a certain dumb node, so when something happens.

// There are 3 main methods to add event listeners:

//  1.  using on-event propery directly on the element
//      element.onmouseenter = function() {...};
//      this is the old way of attaching events

//  2.  add event in HTML like: onclick="alert(`hello`)"
//      never use this

//  3.  element.addEventListener(`mouseenter`, function() {...})
//      it allows to add multiple event listeners to the same event.
//      also it allows you to remove an event listener
//      element.removeEventListener(`eventType`, functionId)
//      you can remove it in setTimeout() or, for example, in the end of the callback to execute is once

// EXAMPLE:
const h1 = document.querySelector(`h1`);

const alertH1 = function (e) {
  alert(`Hello! Mouse is hovered...`);

  // remove event listener in the end
  h1.removeEventListener(`mouseenter`, alertH1);
};

// mouseenter is like :hover in css
h1.addEventListener(`mouseenter`, alertH1);






///////////////////////////////////////////////
// Event propagation: bubbling and capturing //
///////////////////////////////////////////////

// JS have important property: capturing phase and a bubbling phase.
// For example if you click on anchor link an event happens,
// but, usually, the event is not generated on the anchor link element, but in the root document.

// The way of event:
//  1.  Most of events are generated in the root element
//  2.  Capturing phase: event then travels all the way down from the document route to the target element.
//      Event is passing through every single parent element.
//  3.  Target pahes: when event reach the target and can be handled right at the target.
//      We're handling the events with event listeners and attach there callback function
//  4.  Bubbling phase: event then travels all the way up to the document route again
//      the event passes through all its parent elements againg (not any sibling elements)

// (!)
// Bubbling is important because if you attach the same event listener, also for example,
// to the parent element, then you would get the exact same result (callback)
// so you would have handled the exact same event twice

// Note: not all type of event do Capturing and Bubbling (but almost any)







/////////////////////////////////
// Event propagation: practice //
/////////////////////////////////


// Now if you click on child element (<a>) also both parent elements'll change background color
// This happens because parent elements handles the event listener also on children (during bubbling)


// IMPORTANT:
// `event.target`         --> is element where events happens and not the element where event listener is attached
// `event.currentTarget`  --> is element on which is attached the event listener and not element where event happens
// so: event.currentTarget === `this` keyword


// You can stop the event propagation (parent elements don't handel event of children)
// event.stopPropagation();


// You can catch events during the Capturing and not Bubbling (default)
// To do that you need to set the 3rd parameter of addEventListener() to true
// element.addEventListener(`event`, callback, boolean)
// so if  `true`: the event handler will no longer listen to bubbling events but instead, to capturing events.
// if `false` default the event handler will listen during bubbling
// NOT really usuful in modern days



EXAMPLE:
---------------------------------------------------------------------------------
// function which creates a random number between MIN and MAX
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1)) + min;

// 3 event listeners on <a>, <li> and <nav> (where last is parent) to change color on random on click
document.querySelector(`.nav__link`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);

  // stop event propagation
  e.stopPropagation();
});

document.querySelector(`.nav__links`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});

document.querySelector(`.nav`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});
---------------------------------------------------------------------------------







////////////////////////////////////////////////////
// Event delegation: implementing page navigation //
////////////////////////////////////////////////////



---------------------------------------------------------------------------------
NOT EFFICIENT WAY:

// this works fine but it's not efficient
// because I added the exact same callback function 3 times (unnecessary)
// if I have 1000 elements it's gonna affect the performance by copiing the callback 1000 times...



// get the nodeList of all `.nav__link` and attach event listener to all of them
document.querySelectorAll(`.nav__link`).forEach(function (element) {
  element.addEventListener(`click`, function (event) {
    // prevent default behavior for all events (moving to href="#id")
    event.preventDefault();

    // get the href attribute of the current element
    const id = element.getAttribute(`href`); // example output: "#section--3"

    // so onclick scrollIntoView to that id
    document.querySelector(id).scrollIntoView({ behavior: `smooth` });
  });
});

---------------------------------------------------------------------------------
EFFICIENT WAY USING EVENT DELEGATION:

// The better solution is to use event delegation
// so we use the fact that event is bubbled up
// so we need to attach event listener to the common parent (container) of all interested elements.


//  add event listener to common parent (container) of all interested elements.
document
  .querySelector(`.nav__links`)
  .addEventListener(`click`, function (event) {
    // prevent default behavior
    event.preventDefault();

    // determine what element originated the event
    const eventElement = event.target;

    // check if eventElement is actually interested element (.nav__link)
    if (eventElement.classList.contains(`nav__link`)) {

      // if it's interested element get the href attribute of the element and store it in "idHref"
      const idHref = eventElement.getAttribute(`href`);

      // then scroll to that id "idHref"
      document.querySelector(idHref).scrollIntoView({ behavior: `smooth` });
    }
  });
---------------------------------------------------------------------------------







////////////////////
// DOM traversing //
////////////////////


// Traversing = you can select an element based on another element.
//              (like direct child or a direct parent element)
// indeed you can also set this properties or set, for example, their style (not only read)



const h1 = document.querySelector(`h1`);



// ------------------- CHILDREN ------------------- //



//    element.querySelectorAll(`...`)
// return Nodelist with CHILDREN elements and doesn't matter how deep they are
console.log(h1.querySelectorAll(`.highlight`));

//    element.childNodes
// return NodeList with all direct children
console.log(h1.childNodes);

//    element.children
// return HTMLCollection (live collection) with all direct children real elements (for example no comments)
console.log(h1.children);

//    element.firstElementChild
// return first element child of HTMLCollection
console.log(h1.firstElementChild);
h1.firstElementChild.style.color = `white`; // example of setting style

//    element.lastElementChild
// return last element child of HTMLCollection
console.log(h1.lastElementChild);



// ------------------- PARENTS ------------------- //



//    element.parentNode
// return the Nodelist/element direct parent
console.log(h1.parentNode);

//    element.parentElement
// return the direct parent (usually use this)
console.log(h1.parentElement);

//    element.closest(`.container/#section1/h1`)
// return Nodelist/element with PARENTS elements and doesn't matter how deep (up) they are
console.log(h1.closest(`header`));
console.log(h1.closest(`h1`)); // return the same element



// ------------------- SIBLINGS ------------------- //



//    element.previousElementSibling
// return the previous direct sibling
console.log(h1.previousElementSibling);

//    element.nextElementSibling
// return the next direct sibling
console.log(h1.nextElementSibling);

//    element.previousElementSibling
// return the NodeList with previous direct sibling
console.log(h1.previousSibling);

//    element.nextElementSibling
// return the NodeList with next direct sibling
console.log(h1.nextSibling);

//    element.parentElement.children
// return the HTMLCollection with all siblings (element inclusive)
console.log(h1.parentElement.children);

// do something with all siblings but not element itself
[...h1.parentElement.children].forEach(function (element) {
  if (element !== h1) {
    console.log(`Do something here with siblings`);
  }
});







/////////////////////////////////
// Building a tabbed component //
/////////////////////////////////

// selecting elements to work with tabs
const tabsContainer = document.querySelector(`.operations__tab-container`);
const tabsBtns = document.querySelectorAll(`.operations__tab`);
const tabsContents = document.querySelectorAll(`.operations__content`);

// using event delegation, so add event listener on container
tabsContainer.addEventListener(`click`, function (event) {
  // preventing default just to be sure (not really necessary)
  event.preventDefault();

  // get the element (during bubbling) which provocated event --> event.target
  // and find the actual button because there is the <span> inside --> .closest(`.operations__tab`);
  const clickedBtn = event.target.closest(`.operations__tab`);

  // if `clickedBtn` is null so there was a click on container and not button then just exit function
  if (!clickedBtn) return;

  // otherwise get the `data-tab` attribute to understand which content should be shown
  const numberContent = clickedBtn.dataset.tab;

  // remove active class from all tab buttons
  // and add active class only on clicked tab button
  tabsBtns.forEach(el => el.classList.remove(`operations__tab--active`));
  clickedBtn.classList.add(`operations__tab--active`);

  // remove active class from all <div>s with content to show
  // and add active class only to <div> with correct numberContent class
  tabsContents.forEach(el =>
    el.classList.remove(`operations__content--active`)
  );
  document
    .querySelector(`.operations__content--${numberContent}`)
    .classList.add(`operations__content--active`);
});







/////////////////////////////////////////
// Passing arguments to event handlers //
/////////////////////////////////////////


// NOTE:
//  `mouseover` and `mouseout` do bubbling
//  `mouseenter` and `mouseleave` don't do bubbling


const changeOpacityNav = function (event, opacity) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = opacity;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = opacity;
  }
};

const navBar = document.querySelector(`.nav`);

navBar.addEventListener(`mouseover`, function (event) {
  changeOpacityNav(event, 0.5);
});

navBar.addEventListener(`mouseout`, function (event) {
  changeOpacityNav(event, 1);
});




//// --------------- BEST SOLUTION --------------- ////




// The best way to pass argument into an event handlers' callback function
// is to use bind method, set the `this` keyword and pass `this` as variable inside the callback body
// any event handler function can have only 1 real argument, which is the `event`
// if you want to pass more arguments set `this` in bind to an array or object

const navBar = document.querySelector(`.nav`);

const changeOpacityNav = function (event) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = this;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = this;
  }
};

navBar.addEventListener(`mouseover`, changeOpacityNav.bind(0.5));
navBar.addEventListener(`mouseout`, changeOpacityNav.bind(1));







////////////////////////////////////////////////////////
// Implementing a sticky navigation: the scroll event //
////////////////////////////////////////////////////////



//// -------------- OLD BAD SOLUTION -------------- ////



// REMEMBER:
// const navBar = document.querySelector(`.nav`);
// const section1 = document.getElementById(`section--1`);

// calculate the coordinates of section1
const seciton1Coordinates = section1.getBoundingClientRect();

window.addEventListener(`scroll`, function () {
  if (window.scrollY > seciton1Coordinates.top) {
    navBar.classList.add(`sticky`);
  } else {
    navBar.classList.remove(`sticky`);
  }
});







///////////////////////////////////
// The intersection Observer API //
///////////////////////////////////

