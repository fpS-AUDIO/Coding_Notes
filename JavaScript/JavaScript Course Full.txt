09. ADVANCED DOM AND EVENTS
        - Event delegation: implementing page navigation         
        - DOM traversing
        - Building a tabbed component
        - Passing arguments to event handlers
        - Implementing a sticky navigation: the scroll event

___________________________________________________________________________________________________________________________________
09. ADVANCED DOM AND EVENTS




////////////////////////////////////////////////////
// Event delegation: implementing page navigation //
////////////////////////////////////////////////////



---------------------------------------------------------------------------------
NOT EFFICIENT WAY:

// this works fine but it's not efficient
// because I added the exact same callback function 3 times (unnecessary)
// if I have 1000 elements it's gonna affect the performance by copiing the callback 1000 times...



// get the nodeList of all `.nav__link` and attach event listener to all of them
document.querySelectorAll(`.nav__link`).forEach(function (element) {
  element.addEventListener(`click`, function (event) {
    // prevent default behavior for all events (moving to href="#id")
    event.preventDefault();

    // get the href attribute of the current element
    const id = element.getAttribute(`href`); // example output: "#section--3"

    // so onclick scrollIntoView to that id
    document.querySelector(id).scrollIntoView({ behavior: `smooth` });
  });
});

---------------------------------------------------------------------------------
EFFICIENT WAY USING EVENT DELEGATION:

// The better solution is to use event delegation
// so we use the fact that event is bubbled up
// so we need to attach event listener to the common parent (container) of all interested elements.


//  add event listener to common parent (container) of all interested elements.
document
  .querySelector(`.nav__links`)
  .addEventListener(`click`, function (event) {
    // prevent default behavior
    event.preventDefault();

    // determine what element originated the event
    const eventElement = event.target;

    // check if eventElement is actually interested element (.nav__link)
    if (eventElement.classList.contains(`nav__link`)) {

      // if it's interested element get the href attribute of the element and store it in "idHref"
      const idHref = eventElement.getAttribute(`href`);

      // then scroll to that id "idHref"
      document.querySelector(idHref).scrollIntoView({ behavior: `smooth` });
    }
  });
---------------------------------------------------------------------------------







////////////////////
// DOM traversing //
////////////////////


// Traversing = you can select an element based on another element.
//              (like direct child or a direct parent element)
// indeed you can also set this properties or set, for example, their style (not only read)



const h1 = document.querySelector(`h1`);



// ------------------- CHILDREN ------------------- //



//    element.querySelectorAll(`...`)
// return Nodelist with CHILDREN elements and doesn't matter how deep they are
console.log(h1.querySelectorAll(`.highlight`));

//    element.childNodes
// return NodeList with all direct children
console.log(h1.childNodes);

//    element.children
// return HTMLCollection (live collection) with all direct children real elements (for example no comments)
console.log(h1.children);

//    element.firstElementChild
// return first element child of HTMLCollection
console.log(h1.firstElementChild);
h1.firstElementChild.style.color = `white`; // example of setting style

//    element.lastElementChild
// return last element child of HTMLCollection
console.log(h1.lastElementChild);



// ------------------- PARENTS ------------------- //



//    element.parentNode
// return the Nodelist/element direct parent
console.log(h1.parentNode);

//    element.parentElement
// return the direct parent (usually use this)
console.log(h1.parentElement);

//    element.closest(`.container/#section1/h1`)
// return Nodelist/element with PARENTS elements and doesn't matter how deep (up) they are
console.log(h1.closest(`header`));
console.log(h1.closest(`h1`)); // return the same element



// ------------------- SIBLINGS ------------------- //



//    element.previousElementSibling
// return the previous direct sibling
console.log(h1.previousElementSibling);

//    element.nextElementSibling
// return the next direct sibling
console.log(h1.nextElementSibling);

//    element.previousElementSibling
// return the NodeList with previous direct sibling
console.log(h1.previousSibling);

//    element.nextElementSibling
// return the NodeList with next direct sibling
console.log(h1.nextSibling);

//    element.parentElement.children
// return the HTMLCollection with all siblings (element inclusive)
console.log(h1.parentElement.children);

// do something with all siblings but not element itself
[...h1.parentElement.children].forEach(function (element) {
  if (element !== h1) {
    console.log(`Do something here with siblings`);
  }
});







/////////////////////////////////
// Building a tabbed component //
/////////////////////////////////

// selecting elements to work with tabs
const tabsContainer = document.querySelector(`.operations__tab-container`);
const tabsBtns = document.querySelectorAll(`.operations__tab`);
const tabsContents = document.querySelectorAll(`.operations__content`);

// using event delegation, so add event listener on container
tabsContainer.addEventListener(`click`, function (event) {
  // preventing default just to be sure (not really necessary)
  event.preventDefault();

  // get the element (during bubbling) which provocated event --> event.target
  // and find the actual button because there is the <span> inside --> .closest(`.operations__tab`);
  const clickedBtn = event.target.closest(`.operations__tab`);

  // if `clickedBtn` is null so there was a click on container and not button then just exit function
  if (!clickedBtn) return;

  // otherwise get the `data-tab` attribute to understand which content should be shown
  const numberContent = clickedBtn.dataset.tab;

  // remove active class from all tab buttons
  // and add active class only on clicked tab button
  tabsBtns.forEach(el => el.classList.remove(`operations__tab--active`));
  clickedBtn.classList.add(`operations__tab--active`);

  // remove active class from all <div>s with content to show
  // and add active class only to <div> with correct numberContent class
  tabsContents.forEach(el =>
    el.classList.remove(`operations__content--active`)
  );
  document
    .querySelector(`.operations__content--${numberContent}`)
    .classList.add(`operations__content--active`);
});







/////////////////////////////////////////
// Passing arguments to event handlers //
/////////////////////////////////////////


// NOTE:
//  `mouseover` and `mouseout` do bubbling
//  `mouseenter` and `mouseleave` don't do bubbling


const changeOpacityNav = function (event, opacity) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = opacity;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = opacity;
  }
};

const navBar = document.querySelector(`.nav`);

navBar.addEventListener(`mouseover`, function (event) {
  changeOpacityNav(event, 0.5);
});

navBar.addEventListener(`mouseout`, function (event) {
  changeOpacityNav(event, 1);
});




//// --------------- BEST SOLUTION --------------- ////




// The best way to pass argument into an event handlers' callback function
// is to use bind method, set the `this` keyword and pass `this` as variable inside the callback body
// any event handler function can have only 1 real argument, which is the `event`
// if you want to pass more arguments set `this` in bind to an array or object

const navBar = document.querySelector(`.nav`);

const changeOpacityNav = function (event) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = this;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = this;
  }
};

navBar.addEventListener(`mouseover`, changeOpacityNav.bind(0.5));
navBar.addEventListener(`mouseout`, changeOpacityNav.bind(1));







////////////////////////////////////////////////////////
// Implementing a sticky navigation: the scroll event //
////////////////////////////////////////////////////////



//// -------------- OLD BAD SOLUTION -------------- ////



// REMEMBER:
// const navBar = document.querySelector(`.nav`);
// const section1 = document.getElementById(`section--1`);

// calculate the coordinates of section1
const seciton1Coordinates = section1.getBoundingClientRect();

window.addEventListener(`scroll`, function () {
  if (window.scrollY > seciton1Coordinates.top) {
    navBar.classList.add(`sticky`);
  } else {
    navBar.classList.remove(`sticky`);
  }
});







///////////////////////////////////
// The intersection Observer API //
///////////////////////////////////

