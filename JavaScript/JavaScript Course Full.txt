09. ADVANCED DOM AND EVENTS
        - Types of events and event handlers
        - Event propagation: bubbling and capturing
        - Event propagation: practice 
        - Event delegation: implementing page navigation         
        - DOM traversing
        - Building a tabbed component
        - Passing arguments to event handlers
        - Implementing a sticky navigation: the scroll event

___________________________________________________________________________________________________________________________________
09. ADVANCED DOM AND EVENTS





////////////////////////////////////////
// Types of events and event handlers //
////////////////////////////////////////

// Events:
// an event is a signal generated by a certain dumb node, so when something happens.

// There are 3 main methods to add event listeners:

//  1.  using on-event propery directly on the element
//      element.onmouseenter = function() {...};
//      this is the old way of attaching events

//  2.  add event in HTML like: onclick="alert(`hello`)"
//      never use this

//  3.  element.addEventListener(`mouseenter`, function() {...})
//      it allows to add multiple event listeners to the same event.
//      also it allows you to remove an event listener
//      element.removeEventListener(`eventType`, functionId)
//      you can remove it in setTimeout() or, for example, in the end of the callback to execute is once

// EXAMPLE:
const h1 = document.querySelector(`h1`);

const alertH1 = function (e) {
  alert(`Hello! Mouse is hovered...`);

  // remove event listener in the end
  h1.removeEventListener(`mouseenter`, alertH1);
};

// mouseenter is like :hover in css
h1.addEventListener(`mouseenter`, alertH1);






///////////////////////////////////////////////
// Event propagation: bubbling and capturing //
///////////////////////////////////////////////

// JS have important property: capturing phase and a bubbling phase.
// For example if you click on anchor link an event happens,
// but, usually, the event is not generated on the anchor link element, but in the root document.

// The way of event:
//  1.  Most of events are generated in the root element
//  2.  Capturing phase: event then travels all the way down from the document route to the target element.
//      Event is passing through every single parent element.
//  3.  Target pahes: when event reach the target and can be handled right at the target.
//      We're handling the events with event listeners and attach there callback function
//  4.  Bubbling phase: event then travels all the way up to the document route again
//      the event passes through all its parent elements againg (not any sibling elements)

// (!)
// Bubbling is important because if you attach the same event listener, also for example,
// to the parent element, then you would get the exact same result (callback)
// so you would have handled the exact same event twice

// Note: not all type of event do Capturing and Bubbling (but almost any)







/////////////////////////////////
// Event propagation: practice //
/////////////////////////////////


// Now if you click on child element (<a>) also both parent elements'll change background color
// This happens because parent elements handles the event listener also on children (during bubbling)


// IMPORTANT:
// `event.target`         --> is element where events happens and not the element where event listener is attached
// `event.currentTarget`  --> is element on which is attached the event listener and not element where event happens
// so: event.currentTarget === `this` keyword


// You can stop the event propagation (parent elements don't handel event of children)
// event.stopPropagation();


// You can catch events during the Capturing and not Bubbling (default)
// To do that you need to set the 3rd parameter of addEventListener() to true
// element.addEventListener(`event`, callback, boolean)
// so if  `true`: the event handler will no longer listen to bubbling events but instead, to capturing events.
// if `false` default the event handler will listen during bubbling
// NOT really usuful in modern days



EXAMPLE:
---------------------------------------------------------------------------------
// function which creates a random number between MIN and MAX
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1)) + min;

// 3 event listeners on <a>, <li> and <nav> (where last is parent) to change color on random on click
document.querySelector(`.nav__link`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);

  // stop event propagation
  e.stopPropagation();
});

document.querySelector(`.nav__links`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});

document.querySelector(`.nav`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});
---------------------------------------------------------------------------------







////////////////////////////////////////////////////
// Event delegation: implementing page navigation //
////////////////////////////////////////////////////



---------------------------------------------------------------------------------
NOT EFFICIENT WAY:

// this works fine but it's not efficient
// because I added the exact same callback function 3 times (unnecessary)
// if I have 1000 elements it's gonna affect the performance by copiing the callback 1000 times...



// get the nodeList of all `.nav__link` and attach event listener to all of them
document.querySelectorAll(`.nav__link`).forEach(function (element) {
  element.addEventListener(`click`, function (event) {
    // prevent default behavior for all events (moving to href="#id")
    event.preventDefault();

    // get the href attribute of the current element
    const id = element.getAttribute(`href`); // example output: "#section--3"

    // so onclick scrollIntoView to that id
    document.querySelector(id).scrollIntoView({ behavior: `smooth` });
  });
});

---------------------------------------------------------------------------------
EFFICIENT WAY USING EVENT DELEGATION:

// The better solution is to use event delegation
// so we use the fact that event is bubbled up
// so we need to attach event listener to the common parent (container) of all interested elements.


//  add event listener to common parent (container) of all interested elements.
document
  .querySelector(`.nav__links`)
  .addEventListener(`click`, function (event) {
    // prevent default behavior
    event.preventDefault();

    // determine what element originated the event
    const eventElement = event.target;

    // check if eventElement is actually interested element (.nav__link)
    if (eventElement.classList.contains(`nav__link`)) {

      // if it's interested element get the href attribute of the element and store it in "idHref"
      const idHref = eventElement.getAttribute(`href`);

      // then scroll to that id "idHref"
      document.querySelector(idHref).scrollIntoView({ behavior: `smooth` });
    }
  });
---------------------------------------------------------------------------------







////////////////////
// DOM traversing //
////////////////////


// Traversing = you can select an element based on another element.
//              (like direct child or a direct parent element)
// indeed you can also set this properties or set, for example, their style (not only read)



const h1 = document.querySelector(`h1`);



// ------------------- CHILDREN ------------------- //



//    element.querySelectorAll(`...`)
// return Nodelist with CHILDREN elements and doesn't matter how deep they are
console.log(h1.querySelectorAll(`.highlight`));

//    element.childNodes
// return NodeList with all direct children
console.log(h1.childNodes);

//    element.children
// return HTMLCollection (live collection) with all direct children real elements (for example no comments)
console.log(h1.children);

//    element.firstElementChild
// return first element child of HTMLCollection
console.log(h1.firstElementChild);
h1.firstElementChild.style.color = `white`; // example of setting style

//    element.lastElementChild
// return last element child of HTMLCollection
console.log(h1.lastElementChild);



// ------------------- PARENTS ------------------- //



//    element.parentNode
// return the Nodelist/element direct parent
console.log(h1.parentNode);

//    element.parentElement
// return the direct parent (usually use this)
console.log(h1.parentElement);

//    element.closest(`.container/#section1/h1`)
// return Nodelist/element with PARENTS elements and doesn't matter how deep (up) they are
console.log(h1.closest(`header`));
console.log(h1.closest(`h1`)); // return the same element



// ------------------- SIBLINGS ------------------- //



//    element.previousElementSibling
// return the previous direct sibling
console.log(h1.previousElementSibling);

//    element.nextElementSibling
// return the next direct sibling
console.log(h1.nextElementSibling);

//    element.previousElementSibling
// return the NodeList with previous direct sibling
console.log(h1.previousSibling);

//    element.nextElementSibling
// return the NodeList with next direct sibling
console.log(h1.nextSibling);

//    element.parentElement.children
// return the HTMLCollection with all siblings (element inclusive)
console.log(h1.parentElement.children);

// do something with all siblings but not element itself
[...h1.parentElement.children].forEach(function (element) {
  if (element !== h1) {
    console.log(`Do something here with siblings`);
  }
});







/////////////////////////////////
// Building a tabbed component //
/////////////////////////////////

// selecting elements to work with tabs
const tabsContainer = document.querySelector(`.operations__tab-container`);
const tabsBtns = document.querySelectorAll(`.operations__tab`);
const tabsContents = document.querySelectorAll(`.operations__content`);

// using event delegation, so add event listener on container
tabsContainer.addEventListener(`click`, function (event) {
  // preventing default just to be sure (not really necessary)
  event.preventDefault();

  // get the element (during bubbling) which provocated event --> event.target
  // and find the actual button because there is the <span> inside --> .closest(`.operations__tab`);
  const clickedBtn = event.target.closest(`.operations__tab`);

  // if `clickedBtn` is null so there was a click on container and not button then just exit function
  if (!clickedBtn) return;

  // otherwise get the `data-tab` attribute to understand which content should be shown
  const numberContent = clickedBtn.dataset.tab;

  // remove active class from all tab buttons
  // and add active class only on clicked tab button
  tabsBtns.forEach(el => el.classList.remove(`operations__tab--active`));
  clickedBtn.classList.add(`operations__tab--active`);

  // remove active class from all <div>s with content to show
  // and add active class only to <div> with correct numberContent class
  tabsContents.forEach(el =>
    el.classList.remove(`operations__content--active`)
  );
  document
    .querySelector(`.operations__content--${numberContent}`)
    .classList.add(`operations__content--active`);
});







/////////////////////////////////////////
// Passing arguments to event handlers //
/////////////////////////////////////////


// NOTE:
//  `mouseover` and `mouseout` do bubbling
//  `mouseenter` and `mouseleave` don't do bubbling


const changeOpacityNav = function (event, opacity) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = opacity;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = opacity;
  }
};

const navBar = document.querySelector(`.nav`);

navBar.addEventListener(`mouseover`, function (event) {
  changeOpacityNav(event, 0.5);
});

navBar.addEventListener(`mouseout`, function (event) {
  changeOpacityNav(event, 1);
});




//// --------------- BEST SOLUTION --------------- ////




// The best way to pass argument into an event handlers' callback function
// is to use bind method, set the `this` keyword and pass `this` as variable inside the callback body
// any event handler function can have only 1 real argument, which is the `event`
// if you want to pass more arguments set `this` in bind to an array or object

const navBar = document.querySelector(`.nav`);

const changeOpacityNav = function (event) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = this;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = this;
  }
};

navBar.addEventListener(`mouseover`, changeOpacityNav.bind(0.5));
navBar.addEventListener(`mouseout`, changeOpacityNav.bind(1));







////////////////////////////////////////////////////////
// Implementing a sticky navigation: the scroll event //
////////////////////////////////////////////////////////



//// -------------- OLD BAD SOLUTION -------------- ////



// REMEMBER:
// const navBar = document.querySelector(`.nav`);
// const section1 = document.getElementById(`section--1`);

// calculate the coordinates of section1
const seciton1Coordinates = section1.getBoundingClientRect();

window.addEventListener(`scroll`, function () {
  if (window.scrollY > seciton1Coordinates.top) {
    navBar.classList.add(`sticky`);
  } else {
    navBar.classList.remove(`sticky`);
  }
});







///////////////////////////////////
// The intersection Observer API //
///////////////////////////////////

