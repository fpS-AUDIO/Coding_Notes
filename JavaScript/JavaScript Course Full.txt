
06. A CLOSER LOOK AT THE FUNCTIONS
        - Default parameters                                V
        - How passing arguments works: value vs reference   V
        - First-class and higher-order functions
        - Functions accepting the callback functions
        - Functions returning functions
        - The call and apply methods
        - The bind method
        - Immediately Invoked Function Expressions (IIFE)
        - Closures

07. WORKING WITH ARRAYS
        - Simple Array Methods
        - The at() method
        - Looping arrayes with forEach() method
        - forEach() method with Maps and Sets
        - Manipulating DOM Elements
        - Data transformations: map() 
        - Data transformations: filter()
        - Data transformations: reduce()
        - Data transformations: find()
        - Data transformations: findIndex()
        - Data transformations: some() and every()
        - Data transformations: flat() and flatMap()
        - Data transformations: sort()
        - Data transformations: fill() and Array.from()

08. NUMBERS, DATES AND TIMERS        
        - Converting and Checking Numbers
        - Math and Rounding
        - The remainder operator
        - Numeric separators 
        - Working with BigInt
        - Creating dates
        - Operations with dates
        - Internationalizing dates (INTL)
        - Internationalizing numbers (INTL)
        - Timers: setTimeout and setInterval

09. ADVANCED DOM AND EVENTS
        - How the DOM really works 
        - Selecting, creating and deleting elements
        - Styles, attributes and classes
        - Implementing Smooth scrolling 
        - Types of events and event handlers
        - Event propagation: bubbling and capturing
        - Event propagation: practice 
        - Event delegation: implementing page navigation         
        - DOM traversing
        - Building a tabbed component
        - Passing arguments to event handlers
        - Implementing a sticky navigation: the scroll event

 



___________________________________________________________________________________________________________________________________
06. A CLOSER LOOK AT THE FUNCTIONS



////////////////////////////////////////////
// First-class and higher-order functions //
////////////////////////////////////////////


(!) first class functions is just a concept that a programming language has or doesn't have.
    (it means is that all functions are values).

    higher order functions is not just a concept, they are real.
    and they are possible only because the language support first class functions.



JS has first class functions so:
    - JS treats functions as first-class citizens (as values)
    - functions are just another "type" of object

Since object are values, the functions are values too and you can:
    - storing them in variables or object properties
    - pass functions as arguments to other functions
    - return a function from another function
    - call function methods like bind() (methods can be called on function like a method on an object)



So since JS has first-class functions you can write higher order functions.

HIGHER ORDER FUNCTION:
    it's a function that receives another function as an argument 
    or a function that returns a new function.

    EXAMPLE:
        addEventListener    -> higher order function
        functionABC         -> callback function

        btn.addEventListener(`click`, functionABC)






///////////////////////////////////////////////
// Functions accepting the callback functions //
///////////////////////////////////////////////

Callback functions help:
    - it makes it easy to split up or code into more reusable and interconnected parts
    - it allows us to create abstraction

Abstraction
    means that we hide the detail of some code implementation because we don't really care about all that detail.
    This allows us to think about problems at a higher more abstract level (name si coming from).

    For example in the transformWord() function below this function doesn't care how the string is transformed.


--------------------------------------------
    EXAMPLE:

const eliminateSpaces = function (str) {
  return str.replaceAll(` `, ``);
};

const upperFirstLetter = function (str) {
  return str.replace(str[0], str[0].toUpperCase());
};


// high order function
const transformWord = function (str, funct) {
  console.log(`Transformed string: ${funct(str)}`);
  console.log(`Trasfomed by: ${funct.name}`);
};


const str1 = `i love JS!`;
transformWord(str1, eliminateSpaces);
transformWord(str1, upperFirstLetter);






///////////////////////////////////
// Functions returning functions //
///////////////////////////////////

(!) They are so useful if you use programming paradigm called functional programming


--------------------------------------------
    EXAMPLE:


// function returning other function
const greet = function (greetStr) {
  return function (name) {
    console.log(`${greetStr} ${name}`);
  };
};


// the result of greet() function call is a function
// store the result in the variable "greetHello" and now its value it's a function
// this works thanks to closure (difficult topic)
const greetHello = greet(`Hello`);
greetHello(`World`); // output:  Hello World


// so we can write it in a single row since "greet(`Goodmoring`)" is now has the value of function
greet(`Goodmoring`)(`everybody`);
// output:  Goodmoring everybody


// same function but wrote as Arrow Function
const greetArrow = (greetStr) => (name) => console.log(`${greetStr} ${name}`);
greetArrow(`Hi`)(`People`);
// output:  Hi People






////////////////////////////////
// The call and apply methods //
////////////////////////////////


call()  
    allows you to manually set the this keyword of any function that we want to call. 
    function.call(object_to_point_this, other_arguments_of_function)

apply()
    does the same but it doesn't recieve a list of arguments after the "this" keyword,
    but it takes an array of arguments. 
    It's an OLD WAY since you can just use the spread operator.


/////////////// data for example below ///////////////

const lufthansa = {
  airline: `Lufthansa`,
  fligthCode: `LH`,
  bookings: [],

  book(flightNumber, passengerName) {
    console.log(
      `${passengerName} booked a seat on ${this.airline} flight ${this.fligthCode}${flightNumber}`
    );
    this.bookings.push({
      flight: `${this.fligthCode}${flightNumber}`,
      name: passengerName,
    });
  },
};

const alitalia = {
  airline: `Alitalia`,
  fligthCode: `AL`,
  bookings: [],
};





// trying to call method
lufthansa.book(463, `Alexander Smith`); // Alexander Smith booked a seat on Lufthansa flight LH463
lufthansa.book(723, `Sara Cattaneo`); // Sara Cattaneo booked a seat on Lufthansa flight LH723

console.log(lufthansa.bookings);
// OUTPUT: [
//    {flight: 'LH463', name: 'Alexander Smith'},
//    {flight: 'LH723', name: 'Sara Cattaneo'}
//  ]


////////////////////////////////////////////////////////




// taking method and store it in an external function
const bookFlight = lufthansa.book;

//    PROBLEM
// bookFlight(234, `John Chan`);
// Uncaught TypeError: Cannot read properties of undefined (reading 'airline')
// now bookFlight() is not more a method but it's a regular function call,
// so the this keyword points to undefined (at least in strict mode)

//    TO FIX THIS PROBLEM WITH CALL()
// you can use:   function.call(object_point_this, all_other_arguments)
bookFlight.call(alitalia, 463, `Marco Rossi`); // Marco Rossi booked a seat on Alitalia flight AL463
bookFlight.call(lufthansa, 732, `Anna Rich`); // Anna Rich booked a seat on Lufthansa flight LH732

//    APPLY ()
const argArray = [426, `Jonas Sils`];
bookFlight.apply(alitalia, argArray); // Jonas Sils booked a seat on Alitalia flight AL426

//    modern way using spread operator
bookFlight.call(lufthansa, ...argArray); // Jonas Sils booked a seat on Lufthansa flight LH426






/////////////////////
// The bind method //
/////////////////////


// bind() is similar to the call() method but it doesn't immediately call the function
// it returns a new function where the "this" keyword is bound (set to the correct value)
// also you can bind the parameters in correct order
// partial application means that a part of the arguments of the original function are already set.
// if you don't need to specify "this" you can pass a "null" as the first argument

/////////////////// data for example below ///////////////////
const lufthansa = {
  airline: `Lufthansa`,
  fligthCode: `LH`,
  bookings: [],

  book(flightNumber, passengerName) {
    console.log(
      `${passengerName} booked a seat on ${this.airline} flight ${this.fligthCode}${flightNumber}`
    );
    this.bookings.push({
      flight: `${this.fligthCode}${flightNumber}`,
      name: passengerName,
    });
  },
};

const alitalia = {
  airline: `Alitalia`,
  fligthCode: `AL`,
  bookings: [],
};

//---------------------------------------------------------------------------------------//

const bookFlight = lufthansa.book;

const bookAlitalia = bookFlight.bind(alitalia); // returning and not calling a new function
bookAlitalia(329, `Alessia`); // Alessia booked a seat on Alitalia flight AL329

// binding the first argument "388"
const bookAlitalia388 = bookAlitalia.bind(alitalia, 388);
bookAlitalia388(`Steve`); // Steve booked a seat on Alitalia flight AL388

//---------------------------------------------------------------------------------------//

// with event listeners
lufthansa.planes = 250;
lufthansa.buyNewPlane = function () {
  this.planes++;
  console.log(this.planes);
};

// Here the "this" keyword is pointing the document.getElementById(`btn0`) which called the function
//    document.getElementById(`btn0`).addEventListener(`click`, lufthansa.buyNewPlane);
// this is the correct way with .bind(lufthansa) to point to the lufthansa object
document
  .getElementById(`btn0`)
  .addEventListener(`click`, lufthansa.buyNewPlane.bind(lufthansa));

//---------------------------------------------------------------------------------------//

// Partial Application
// here you are not interested in "this" keyword but you still use bind()

// VAT = Value-added tax
const addVAT = (rate, value) => value + value * rate;
console.log(addVAT(0.1, 100)); // 110

// set up the rate to 22%
const addVAT22 = addVAT.bind(null, 0.22);
console.log(addVAT22(100)); // 122



//---------------------------------------------------------------------------------------//
/// CHALLENGE:
//  DO THE SAME BUT WITH FUNCTION RETURNING OTHER FUNCTION

const challengeAddVAT = function (rate) {
  return function (value) {
    return value + value * rate;
  };
};

const challengeAddVAT22 = challengeAddVAT(0.22);
console.log(challengeAddVAT22(110));
//---------------------------------------------------------------------------------------//






/////////////////////////////////////////////////////
// Immediately Invoked Function Expressions (IIFE) //
/////////////////////////////////////////////////////

// You can create a function which will be executed once and then it'll dissapear.
// you need to make JS thinks it's an expression by wrapping function iside () and call it
// all data iside a scope is private (encapsulated data)
// so IIFE helps hide variables inside a local scope

// function expression
(function () {
  console.log(`This funtion runs once!`);
})();

// arrow function
(() => console.log(`Also this funtion runs once!`))();

// Variables declared with let or const create their own scope inside a block.
{
  const isPrivate = 28;
}
// console.log(isPrivate); // Uncaught ReferenceError: isPrivate is not defined
// the modern solutions prefer using this block without creating functions.
// since we can create a scope just using {}






//////////////
// Closures //
//////////////

// FORMAL DEFINITION:
// A closure is the closed-over variable environment of the execution context in which a function was created, even after that execution context is gone.

// When the outer function finishes execution, its execution context is no longer on the call stack.
// The function returned (inner) from the outer function creates a new execution context on top of the call stack.
// The variable environment of this context is empty because there are no variables declared in this function.
// Since the second function is in the global context, it is now a child scope of the global scope.
// However, any function always has access to the variable environment of the execution context in which the function was created (even after that execution context is gone).
// So, a closure is a mechanism that connects the variable environment to the function exactly as it was when the function was created.

// Closure
const secureCounting = function () {
  let person = 0;

  return function () {
    person++;
    console.log(person);
  };
};

const addPerson = secureCounting();
addPerson(); // 1
addPerson(); // 2
addPerson(); // 3

// When the addPerson() function is called, it attempts to access the "person" variable.
// Since this variable is not in the current scope, JavaScript searches for it inside the closure.
// This "search" occurs even before looking at the scope chain.
// So, even if you have a global "person" variable, the closure takes priority over the parent scopes.

// (!) Closures are created automatically, and you can't access closed-over variables directly because it's an internal property of a function.

// console.dir() displays an interactive list of the properties of the specified JavaScript object.
console.dir(addPerson);
// Now you can see all properties, including scopes with their closures.
// P.S. Everything inside the double brackets [[...]] is an internal property that you cannot access with code.



// ------------------- MORE CLOSURE EXAMPPLES ------------------- //

// EXAMPLE #1:

let z;

// function "a" which reassigns "z" when called
const a = function () {
  const num = 28;
  z = function () {
    console.log(num);
  };
};

// function "b" which reassigns "z" when called
const b = function () {
  const num = 99;
  z = function () {
    console.log(num);
  };
};

a();
z(); // 28

b();
z(); // 99

// so "z" wehn was reassigned by "b" also closed over the variable environment of "b"
// a closure can be created by reassigning functionz (even without returning them)

// EXAMPLE #2:
const boadPassengers = function (n, waitTimeSeconds) {
  // devide the passengers into 3 equal groups
  const perGroup = n / 3;

  setTimeout(function () {
    console.log(`We are boarding ${n} passengers split in ${perGroup} groups`);
  }, waitTimeSeconds * 1000);

  // the following console.log() will NOT wait for the callback, but it will be executed immediatly when called
  console.log(`We will start boarding in ${waitTimeSeconds} seconds`);
};

boadPassengers(321, 5);
// the callback function has access to the "perGroup" thanks to the closure






// ------------------- setTimeout ------------------- //
// setTimeout(a, b) accept 2 parameters:
//    a. callbackFunction
//    b. milleseconds after which callback will be executed

setTimeout(function () {
  console.log(`setTimeout Message after 3s`);
}, 3000);
// -------------------------------------------------- //











___________________________________________________________________________________________________________________________________
07. WORKING WITH ARRAYS






//////////////////////////
// Simple Array Methods //
//////////////////////////


// -------------------- ARRAY METHODS -------------------- //
/*
at()	            Returns an indexed element of an array
concat()	        Joins arrays and returns an array with the joined arrays
constructor	        Returns the function that created the Array object's prototype
copyWithin()	    Copies array elements within the array, to and from specified positions
entries()	        Returns a key/value pair Array Iteration Object
every()	            Checks if every element in an array pass a test
fill()	            Fill the elements in an array with a static value
filter()	        Creates a new array with every element in an array that pass a test
find()	            Returns the value of the first element in an array that pass a test
findIndex()	        Returns the index of the first element in an array that pass a test
flat()	            Concatenates sub-array elements 
flatMap()	        Maps all array elements and creates a new flat array
forEach()	        Calls a function for each array element
from()	            Creates an array from an object
includes()	        Check if an array contains the specified element (returns true or false)
indexOf()	        Search the array for an element and returns its position (index)
isArray()	        Checks whether an object is an array
join()	            Joins all elements of an array into a string
keys()	            Returns a Array Iteration Object, containing the keys of the original array
lastIndexOf()	    Search the array for an element, starting at the end, and returns its position
length	            Sets or returns the number of elements in an array
map()	            Creates a new array with the result of calling a function for each array element
pop()	            Removes the last element of an array, and returns that element
prototype	        Allows you to add properties and methods to an Array object
push()	            Adds new elements to the end of an array, and returns the new length
reduce()	        Reduce the values of an array to a single value (going left-to-right)
reduceRight()	    Reduce the values of an array to a single value (going right-to-left)
reverse()	        Reverses the order of the elements in an array
shift()	            Removes the first element of an array, and returns that element
slice()	            Selects a part of an array, and returns the new array
some()	            Checks if any of the elements in an array pass a test
sort()	            Sorts the elements of an array
splice()	        Adds/Removes elements from an array
toString()	        Converts an array to a string, and returns the result
unshift()	        Adds new elements to the beginning of an array, and returns the new length
valueOf()	        Returns the primitive value of an array */
// ------------------------------------------------------- //



////////////////// STAFF FROM COURSE  ///////////////////////



// ------------- Data for the examples below ------------- //
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [6, 7, 8, 9, 10];
// ------------------------------------------------------- //

// push()    adds new elements to the end of an array, and returns the new length
// unshift()    adds new elements to the beginning of an array, and returns the new length
// shift()    removes the first element of an array, and returns that element
// pop()    removes the last element of an array, and returns that element
// indexOf()    search the array for an element and returns its position (index)
// includes()    check if an array contains the specified element (returns true or false)

// slice(start, end)    returns a part of an array WITHOUT MUTATING the original one (end is NOT included)
console.log(arr1.slice(2)); // [3, 4, 5]
console.log(arr1.slice(2, 4)); // [3, 4]
console.log(arr1.slice(-2)); // [4, 5]
console.log(arr1.slice(1, -1)); // [2, 3, 4]
console.log(arr1.slice()); // [1, 2, 3, 4, 5] shallow copy (you can chain multiple methods)
console.log([...arr1]); // [1, 2, 3, 4, 5] shallow copy (does the same)

// splice(start, numberOfElementsToRemoveFromStart)    returns the extracted part of an array MUTATING the original one
console.log(arr1.splice(2, 2)); // [3, 4]
console.log(arr1); // [1, 2, 5]

// reverse()    returns the reversed array by MUTATING the original one (doesn't delete elements like splice() )
console.log(arr2.reverse()); // [10, 9, 8, 7, 6]

// array.concat(array2)    returns a new array by concatenating two arrays and WITHOUT MUTATING the original one
const numbers1 = arr1.concat(arr2);
console.log(numbers1); // [1, 2, 5, 10, 9, 8, 7, 6]
console.log([...arr1, ...arr2]); // [1, 2, 5, 10, 9, 8, 7, 6] does the same

// join(separating)    returns a string by joining all the elements of an array with separator between them
console.log(numbers1.join(` - `)); // 1 - 2 - 5 - 10 - 9 - 8 - 7 - 6






/////////////////////
// The at() method //
/////////////////////

const arr1 = [1, 2, 3, 4, 5];

// at(index)    returns the indexed element of an array
console.log(arr1.at(-1)); // 5
console.log(arr1[arr1.length - 1]); // 5
console.log(arr1.slice(-1)[0]); // 5






///////////////////////////////////////////
// Looping arrayes with forEach() method //
///////////////////////////////////////////

//    array.forEach(function(element, index, array) {....})
// loops over the array and executes the callback function on each iteration
// forEach() is a higher order function which requires a callback function
// it passes the current elements of the array as the 1st obbligatory arguments of the callback function
// you can pass also the 2nd and 3rd arugments: index of elements and the entire array
// you CAN'T break out the forEach loop


const movements = [300, -250, -150, 200, -1500, -125];



movements.forEach(function (movement) {
  if (movement > 0) {
    console.log(`You deposited ${movement}`);
  } else {
    console.log(`You withdrew ${movement}`);
  }
});
//    OUTPUT: You deposited 300   etc...



movements.forEach(function (mov, i) {
  if (mov > 0) {
    console.log(`Movement #${i + 1}: You deposited ${mov}`);
  } else {
    console.log(`Movement #${i + 1}: You withdrew ${mov}`);
  }
});
//    OUTPUT: Movement #1: You deposited 300   etc...






//////////////////////////////////////////
//  forEach() method with Maps and Sets //
//////////////////////////////////////////

// forEach() also works with maps and sets

// -------------- WITH MAPS -------------- //
const currencies = new Map([
  [`USD`, `United States Dollar`],
  [`EUR`, `Euro`],
  [`GBP`, `Pound Sterling`],
]);

// forEach(value, key, map)
currencies.forEach(function (value, key) {
  console.log(`${key} is the ${value}`);
});
//    OUTPUT: USD is the United States Dollar   etc...

// -------------- WITH SETS -------------- //

const currencyUnique = new Set([`Euro`, `USD`, `Euro`, `GBP`, `Euro`, `GBP`]);

// forEach(value, _, map)
currencyUnique.forEach(function (value, _, set) {
  console.log(`${value} is the ${value}`);
});
//    OUTPUT: Euro is the Euro   etc...

// (!)  underscore (_) passed as argument means a throwaway variable in JS (unnecessary variable)






////////////////////////////////
//  Manipulating DOM Elements //
////////////////////////////////



// -------------- innerHTML -------------- //

// innerHTML => property similar to textContent, which returns entire html (not only text like textContent)

// you can empty the entire element like container by doing this:
container.innerHTML = ``;

// you can get the html of an element by doingthis:
console.log(container.innerHTML);



// -------------- insertAdjacentHTML -------------- //

// You can create a variable containing the template literal string with HTML.
// Then you can simply "inject" this template literal inside the HTML.

// htmlElement.insertAdjacentHTML(`place`, htmlString);
//  where `place` can be:
//      - "beforebegin"     -> before the html element if it has parent
//      - "afterbegin"      -> inside the html element before the 1st child
//      - "beforeend"       -> inside the html element after the last child
//      - "afterend"        -> after the html element if it has parent

// EXAMPLE:
container.insertAdjacentHTML(`afterbegin`, htmlPiece);



// -------------- preventDefault -------------- //

// when you click submit botton of a form the page will be automatically reloded
// to prevent this you can simpy attach preventDefault() method on the event object passed as parameter in the callback

btn.addEventListener(`click`, function (event) {
    // prevent from submitting
    event.preventDefault()
})



// -------------- blur -------------- //

// to remove the focus from an html element you can call the blur() method on that element when you need that
// EXAMPLE: passwordInput.blur()




//////////////////////////////////
//  Data transformations: map() //
//////////////////////////////////


//  SYNTAX:   array.map(function(element, index, array) {...} )


// returns a new array containing all transformed elements by callback function from all original array elements
//  1. so it loops over the original array
//  2. transform the current element with the callback function,
//  3. push the transformed element to the new array
//  4. finally returns a new array with all transformed elements
// P.S. you can insert more then one "return" statement in the callback body, but only one should be executed (like in if/else)


// EXAMPLE:
// you might need to multiply each element of the original array by 2 (* 2)
// and get the new array where all elements are multiplied


// example in practice
const testArray1 = [1, 2, 3, 4, 5];
const resultArray1 = testArray1.map(function (element) {
  return element * 2;
});
console.log(resultArray1); // [2, 4, 6, 8, 10]


// same but with arraow function
const resultArray1ARROW = testArray1.map((el) => el * 2);
console.log(resultArray1ARROW); // [2, 4, 6, 8, 10]






/////////////////////////////////////
//  Data transformations: filter() //
/////////////////////////////////////

//  SYNTAX:   array.filter(function(element, index, array) {...} )

// The array.filter() method is a tool for filtering elements based on a specified test condition.
// This method returns a new array containing only the elements that pass the specified test condition defined in the callback function.
// The callback function is executed on each iteration, receiving the current element, its index, and the entire array.
// If the condition specified in the callback function after the "return" keyword evaluates to true, the current element will be included in the new filtered array.

// EXAMPLE:
// below we only need to take out only the positive numbers


// example in practice
const numbers = [200, -200, 340, -300, -20, 50, 400, -460];
const positiveNumbers = numbers.filter(function (element) {
  // return condition (true/false)
  return element > 0;
});
console.log(positiveNumbers); // [200, 340, 50, 400]







/////////////////////////////////////
//  Data transformations: reduce() //
/////////////////////////////////////

//  SYNTAX:   array.reduce(callback, initialValueAccumulator);
//            array.reduce(function(accumulator, currentElement, index, array) {...}, initialValueAccumulator);

// returns a single value by "reducing" all array elements
// so it loops over the elements, transform them to obtain only value (accumulator)
// Indeed the callback function is executed every iteration
// In each iteration you have to return the updated accumulator

// EXAMPLE:
// you might need to add all elements together


// example in practice
const moneyMovement = [200, -200, 340, -300, -20, 50, 400, -460];
const moneyBalance = moneyMovement.reduce(function (accumulator, current) {
  return accumulator + current;
}, 0);
console.log(moneyBalance); // 10



// same but with arrow func syntax
const moneyBalanceArrow = moneyMovement.reduce(
  (accum, current) => accum + current,
  0
);
console.log(moneyBalanceArrow); // 10




// EXAMPLE of finding the maximum value
const maxMovement = moneyMovement.reduce((accum, current) => {
  if (accum > current) return accum;
  else return current;
}, moneyMovement[0]);
console.log(maxMovement); // 400







//////////////////////////////////
// Data transformations: find() //
//////////////////////////////////

// SYNTAX:  array.find(callback, thisValue)
//          array.find(function (element, index, array), thisValue)

// The find() method loops over an array and retrieves the first element that satisfies a given condition.
// This method requires a callback function that should return a boolean. If true, the method returns that element.
// The callback function can optionally accept three parameters: the current element, its index, and the entire array.
// Note: If no values satisfy the testing function, undefined is returned.
// Additionally, the second argument of find() allows you to specify the value of the "this" keyword during execution.

// EXAMPLE #1:
// find the 1st negative value
const arrayMovements = [200, 450, -400, 3000, -650, -130, 70, 1300];
const firstNegativeValue = arrayMovements.find(function (el) {
  return el < 0;
});
console.log(firstNegativeValue);

// EXAMPLE #2:
// find an account
const account = accounts.find(el => el.owner === `Alexander Ivanov`);
console.log(account);
// {owner: 'Alexander Ivanov', movements: Array(5), interestRate: 1.2, pin: 1111, username: 'ai'}




////////////////////////////////////////
//  Data transformations: findIndex() //
////////////////////////////////////////


// SYNTAX:  array.findIndex(callback, thisValue)
//          array.findIndex(callback(element, index, array), thisValue)

// The array.findIndex() method requires a callback function that should return a boolean.
// If returned boolean is true, the findIndex() method returns the index of that element.
// The callback function can optionally accept three parameters: the current element, its index, and the entire array.
// Note: If no values satisfy the testing function, the method returns -1.
// Additionally, the second argument of findIndex() allows you to specify the value of the "this" keyword during execution.



const testArrey = [5, 10, 15, 20, 25, 30];


const resultIndex = testArrey.findIndex(function (el) {
  return el / 5 === 5;
});
console.log(resultIndex); // 4



// same but using arrow function syntax
const resultIndexArrow = testArrey.findIndex(el => el / 5 === 5);
console.log(resultIndexArrow); // 4




///////////////////////////////////////////////
//  Data transformations: some() and every() //
///////////////////////////////////////////////

const movements = [
  500, -200, 1000, -300, -400, 49, 700, 300, -800, 1200, -500, -1000, 1500,
];




// SYNTAX:  array.some(callbackFn, thisValue)
//          array.some(function (element, index, array), thisValue)
// some() returns "true" if at least one element of the array passes the test in the callback function
// some() method doesn't mutate the array

// EXAMPLE: check if there is a positive number bigger than 1000
const booleanResult1 = movements.some(el => el > 1000);
console.log(booleanResult1); // true



// ------------------------------------------------------- //



// NOTE:  you can check for equality (without condition) using includes() method
//        so includes() returns true if there is the exact same value inside the array.
// EXAMPLE:
console.log(movements.includes(1000)); // true
console.log(movements.includes(28)); // false



// ------------------------------------------------------- //



// SYNTAX:  array.every(callbackFn, thisValue)
//          array.every(function (element, index, array), thisValue)
// every() method is exactly the same as some() but it returns true only if all elements pass the condition




/////////////////////////////////////////////////
//  Data transformations: flat() and flatMap() //
/////////////////////////////////////////////////

// SYNTAX:  array.flat(depthLevel)
// flat() method returns a new flattened array (removing nested structures)
// depthLevel is an optional parameter (default is 1) which means how deep flattening should go
// "Infinity" keyword can be passed like argument which basically means "max depth"

const testArray = [1, [2, [3]], 4, 5, [[6], 7]];

// 1 level of flatting
const flatTestArray1 = testArray.flat();
console.log(flatTestArray1); // [1, 2, [3], 4, 5, [6], 7]

// 2 levels of flatting
const flatTestArray2 = testArray.flat(2);
console.log(flatTestArray2); // [1, 2, 3, 4, 5, 6, 7]

const flatTestArray3 = testArray.flat(Infinity);
console.log(flatTestArray3); // [1, 2, 3, 4, 5, 6, 7]



// ------------------------------------------------------- //



//  SYNTAX:   array.flatMap(function(element, index, array) {...}, thisValue )
// flatMap() combines flat() and map() methods which is better for the performance
// flatMap() works the same as map() but in the end it "flattens" the result by 1 level




//////////////////////////////////
// Data transformations: sort() //
//////////////////////////////////

//  SYNTAX:   array.sort(callback(a, b))
//            a = current value, b = next value (of any iteration)

// sort() method, by default (without arguments), does the sorting basing on strings from A to Z.
// So if you sort numbers, without giving a callback function with its own rules,
// it converts the numbers to the strings, sorts them (like strings in UTF-16 code units order), and reconverts them to numbers again.
// Careful, this method mutates the original array and returns the reference to the same array.

// Examples with default behavior:
const arrayLetters = [`b`, `c`, `a`, `z`, `d`, `m`];
const arrayNumbers = [-4, 135, 10, 27, -10, -9, 4];

console.log(arrayLetters.sort()); // ['a', 'b', 'c', 'd', 'm', 'z']
console.log(arrayNumbers.sort()); // [-10, -4, -9, 10, 135, 27, 4]

// ------------------------------------------------------- //



// You can change the default behavior by adding the callback function with its own rules
// sort() method keeps looping over the array applying the callback function until everything is sorted

// Rules of the callback function:
//   - If you return a negative value (like -1), then the value "a" will be placed before "b".
//   - If you return a positive value (like 1), then the value "a" will be placed after "b".
//   - If you return 0, the position remains unchanged.

// So:
//    - return < 0  -->  A, B (keep order)
//    - return > 0  -->  B, A (switch order)
//    - return 0    -->  position remains unchanged




// sort in ascending order
const ascendingArrayNumbers = arrayNumbers.sort((a, b) => {
  if (a > b) return 1;
  if (a < b) return -1;
});
console.log(ascendingArrayNumbers); // [-10, -9, -4, 4, 10, 27, 135]

// same result but with easier syntax
const ascendingArrayNumbers2 = arrayNumbers.sort((a, b) => a - b);
console.log(ascendingArrayNumbers2); // [-10, -9, -4, 4, 10, 27, 135]






///////////////////////////////////////////////////
// Data transformations: fill() and Array.from() //
///////////////////////////////////////////////////


// -------------- theory before practice -------------- //

// you can create an hard-coded array like this:
const arr1 = [1, 2, 3, 4, 5];
const arr2 = new Array(1, 2, 3, 4, 5);
console.log(arr1); // [1, 2, 3, 4, 5]
console.log(arr2); // [1, 2, 3, 4, 5]

// but if you specify only one argument (numberIndexes) in array-constructor ...
// ... JS will create an empty array with numberIndexes length
const arr3 = new Array(5);
console.log(arr3); // [empty × 5]

// Note: you CAN'T call many method on empty array like map() method



// ---------------------- fill() ---------------------- //



// SYNTAX:  array.fill(value, startIndex, endIndex)
// You can call fill() method on empty (or not) array.
// This method fills the entire array with the given value by mutating it.
// Optionally, while filling, you can pass startIndex and endIndex (not included)

const arr4 = arr3.fill(`Z`);
console.log(arr4); // ['Z', 'Z', 'Z', 'Z', 'Z']

const arr5 = arr4.fill(`A`, 1, -1);
console.log(arr5); //  ['Z', 'A', 'A', 'A', 'Z']



// ------------------- Array.from() ------------------- //



// SYNTAX:  Array.from(arrayLike)
// SYNTAX:  Array.from(arrayLike, map(), thisValueForMapFunc)
// SYNTAX:  Array.from(arrayLike, function(element, index, array) {...}, thisValueForMapFunc)

// creating a new array with Array.from(ObjectWithLengthProperty, map())
const arr6 = Array.from({ length: 5 }, () => `Y`);
console.log(arr6); // ['Y', 'Y', 'Y', 'Y', 'Y']

// same logic but adding arguments to the map() method
const arr7 = Array.from({ length: 5 }, (_, index) => index + 1);
console.log(arr7); // [1, 2, 3, 4, 5]


// So you can convert an iterable to an array by using Array.from() method.
// For example you convert a NodeList from document.querySelectorAll() to an array.
// You need to do this conversion to be able to apply array-instances methods on them.

// NOTE: from() method is used on Array Object and NOT on instances


// NOTE: also you can convert an iterable/arrayLike into an array using the spread operator
// but in this case you can't chain methods
console.log([...`HELLO`]); // ['H', 'E', 'L', 'L', 'O']











___________________________________________________________________________________________________________________________________
08. NUMBERS, DATES AND TIMERS






/////////////////////////////////////
// Converting and Checking Numbers //
/////////////////////////////////////

// In JS all numbers are presented internally as floating point numbers (no matter you write them is int or float)
// For this reason we have only one data type for all numbers (28 === 28.0 // true)
// Also numbers are stored in binary format, so it's difficul to represent some fractions (like 0.1)

console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // false

// convert a string to a number
// when JavaScript sees the plus operator, it will do type coercion.

console.log(Number(`28`)); // 28
console.log(+`28`); // 28

// NOTE:  parseInt() and parseFloat() are global functions,
//        so you can call them without Number object,
//        but for good practice you should call them on Number object like Number.parseFloat()
//        Number provides its own namespace




// ----------------- methods of Number object ----------------- //



//    Number.parseInt(str, radix)
// returns an integer number from a string which has to start with a number or space (can include symbols)
// optionally you can (and should) specify the 2nd argument (radix) which is  the base of the numeral system (10, 2 which binary etc)
console.log(Number.parseInt(`2rem`, 10)); // 2
console.log(Number.parseInt(`2.5rem`, 10)); // 2
console.log(Number.parseInt(`rem20`, 10)); // NaN


//    Number.parseFloat(str)
// returns an floating point number from a string which has to start with a number or space (can include symbols)
console.log(Number.parseFloat(`2.5rem`)); // 2.5


//    Number.isNaN(value)
// returns true if the given value is NaN (not a number)
console.log(Number.isNaN(20)); // false
console.log(Number.isNaN(+`20rem`)); // true
console.log(Number.isNaN(10 / 0)); // false (because 10 / 0 = Infinity)


//    Number.isFinite(value)
// returns true if the given value is a finite number (NaN and Infinity are false!)
// it's the best method to check if the value is a real number
console.log(Number.isFinite(28)); // true
console.log(Number.isFinite(28.1)); // true
console.log(Number.isFinite(0)); // true
console.log(Number.isFinite(`28`)); // false


//    Number.isInteger(value)
// returns true if the given value is an Integer
console.log(Number.isInteger(28)); // true
console.log(Number.isInteger(28.0)); // true
console.log(Number.isInteger(28.1)); // false
console.log(Number.isInteger(`28`)); // false






///////////////////////
// Math and Rounding //
///////////////////////

___________________________________________________________________________
// function which creates a random number between MIN and MAX
const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
___________________________________________________________________________


//    Math.sqrt(number)
// returns the square root of the given value
// same result:   number ** (1 / 2)
console.log(Math.sqrt(25)); // 5
console.log(25 ** (1 / 2)); // 5
console.log(8 ** (1 / 3)); // 2 (cubic root)

//    Math.max(value1, value2, value3...)
// return the max value of the given values
// it does type coercion, but it doesn't parsing
console.log(Math.max(1, 2, 3, 4, 5, 6, 6.2)); // 6.2
console.log(Math.max(1, 2, 3, 4, `5`)); // 5
console.log(Math.max(1, 2, 3, 4, `5px`)); // NaN

//    Math.min(value1, value2, value3...)
// return the min value of the given values
// it does type coercion, but it doesn't parsing
console.log(Math.min(1.2, 2, 3, 4, 5)); // 1.2
console.log(Math.min(`1`, 2, 3, 4, 5)); // 1
console.log(Math.min(`px`, 2, 3, 4, 5)); // NaN

// there are different constants on Math Object like PI
console.log(Math.PI); // 3.141592653589793

//    Math.random()         returns a random number between 0-1
//    Math.trunc(number)    removes the decimal part
console.log(Math.trunc(Math.random() * 10)); // returns a random number between 0 and 9
console.log(Math.trunc(Math.random() * 10) + 1); // returns a random number between 1 and 10

// function which creates a random number between MIN and MAX
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1)) + min;

//    Math.trunc(num)
// removes any decimal part (only removing)
console.log(Math.trunc(28.753)); // 28
console.log(Math.trunc(-28.3)); // - 28

//    Math.round(num)
// rounds to the NEAREST integer indeed removing decimal part
console.log(Math.round(28.2)); // 28
console.log(Math.round(28.8)); // 29

//    Math.ceil(num)
// rounds up to the BIGGER integer indeed removing decimal part
console.log(Math.ceil(28.1)); // 29
console.log(Math.ceil(28.8)); // 29

//    Math.floor(num)
// rounds down to the LOWER integer indeed removing decimal part
console.log(Math.floor(28.1)); // 28
console.log(Math.floor(28.8)); // 28
console.log(Math.floor(-28.3)); // - 29

// NOTE:  all these methods also do the type coercion

console.log(`---------------CONTINUE HERE---------------`);

//    (number).toFixed(x)
// RETURNS STRING, round and show x decimal parts of the number
console.log((28).toFixed(2)); // "28.00"
console.log((28.128).toFixed(2)); // "28.13"
console.log((2.1).toFixed()); // "2"
console.log((2.1).toFixed(2)); // "2.10"
console.log((2.8).toFixed()); // "3"

// to return a number with .toFixed()
console.log(+(28.128).toFixed(2)); // 28.13
console.log(+(28.345).toFixed(2)); // 28.34






////////////////////////////
// The remainder operator //
////////////////////////////

// The remainder operator returns a remainder of a divison.
// For example:
//  - if you divide 5 / 2 you get 2.5
//  - if you leave the decimal part, only 2 remains (from 2.5)
//  - now if you multiply your result (2) to the number of divison (2) you get 4 (2*2=4)
//  - then if you subtruct the result (4) from the originl number (5) you get 1 (5-4=1)
//  - and this 1 is the remainer

console.log(5 % 2); // 1 (5 = 2 * 2 + 1 remainder)
console.log(8 % 3); // 2 (8 = 3 * 2 + 2 remainder)
console.log(13 % 3); // 1 (13 = 4 * 3 + 1 remainder)

// you can use this to check if the number is even (because even % 2 = 0)
// with knowledge if the number is even or odd you can do different things

// PRACTICAL EXAMPLE:

// 1. attach an event listener to the "labelBalance" element
// 2. create a NodeList with all elements with "movements__row" class
// 3. transform it into an array usign the spread operator
// 4. check if the current element is even and apply some style on it
// 5.  apply some style on every 3rd index element

labelBalance.addEventListener(`click`, function (e) {
  e.preventDefault();
  [...document.querySelectorAll(`.movements__row`)].forEach(function (el, i) {
    // 0, 2, 4, 6...
    if (i % 2 === 0) {
      el.style.backgroundColor = `#c7c5bf`;
    } // 0, 3, 6, 9
    else if (i % 3 == 0) {
      el.style.backgroundColor = `#8c8a85`;
    }
  });
});






////////////////////////
// Numeric separators //
////////////////////////

// Numeric separator is ES2021 feature
// Numeric separators are simply underscores that you can place anywhere you want between numbers (only 1 in a row)
// It helps you understand the number and these underscores are ignored by hte JS engine.
// Without NS: 836269063348
// With NS: 836_269_063_348

// NOTE: you can't use it in strings before converting the str in a numbers (JS can't use parsing on them)
console.log(Number(`256_000`)); // NaN






/////////////////////////
// Working with BigInt //
/////////////////////////

// Big Integer is a special data type of Integers that was introduced in 2020.
// since in JS the numbers are stored in binary system based on 64 digits we have some limits
// this is the biggest int that JS can represent safely:
console.log(2 ** 53 - 1); // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
// 2 because it's binary
// 53 because there are 53 bits to store the number (the rest of digits are used to store position of decimal point and the sign)

// to transform a really big number into BigInt you can just put "n" in the end of number (hardcode)
// or use BigInt() function with small numbers (safe numbers) and it's usually used to not mix data types.
console.log(231782351283375123n); // 231782351283375123n

// all the operator works the same (but remember that you can't mix BigInt with Numbers)
console.log(25n + 5n); // 30n

// EXCEPTION:
// comparison operators (20n === 20 is false)
// plus operator when working with strings

// Also Math operations are not working with BigInt
// And when you devide bigint the bigint is returned cutting out the decimal part:
console.log(10n / 3n); // 3n






////////////////////
// Creating dates //
////////////////////

// There are 4 WAYS to create a date (because new Date() constructor function accepts different parameters)

// ------------------------------------------------------- //

//  ---> 1). use "new Date()" constructor to obtain the "now" moment

const now = new Date();
console.log(now); // Sun Nov 26 2023 15:51:49 GMT+0100 (Ora standard dell’Europa centrale)

// ------------------------------------------------------- //

//  ---> 2). parse the date from a date string made my constructor (good idea)

const date1 = new Date(`Nov 26 2023 15:54:29`);
console.log(date1); // Sun Nov 26 2023 15:54:29 GMT+0100 (Ora standard dell’Europa centrale)

// ------------------------------------------------------- //

//  ---> 3). write the string manually (not a good idea)

const date2 = new Date(`August 28 1996`);
console.log(date2); // Wed Aug 28 1996 00:00:00 GMT+0200 (Ora legale dell’Europa centrale)

// new Date(year, month, weekDay, hour, minute, second) where january is 0
const date3 = new Date(2025, 7, 28);
console.log(date3); // Thu Aug 28 2025 00:00:00 GMT+0200 (Ora legale dell’Europa centrale)

const date4 = new Date(2025, 0, 40); // January 40th??? It's ok...
console.log(date4); // Sun Feb 09 2025 00:00:00 GMT+0100 (Ora standard dell’Europa centrale)

// ------------------------------------------------------- //

//  ---> 4). new Date(unixTimestampMilliseconds) SECONDS SINCE JAN 01 1970 * 1000

const date5 = new Date(1000);
console.log(date5); // Thu Jan 01 1970 01:00:01 GMT+0100 (Ora standard dell’Europa centrale)

// create date 3 days after the epoch. (3days * 24hours * 60minutes * 60seconds *1000milliseconds)
const date6 = new Date(3 * 24 * 60 * 60 * 1000);
console.log(date6); // Sun Jan 04 1970 01:00:00 GMT+0100 (Ora standard dell’Europa centrale)

const date6Timestamp = 3 * 24 * 60 * 60 * 1000;
console.log(date6Timestamp); // 259200000

// ------------------------------------------------------- //

// ----------------------- methods ----------------------- //

const futureDate = new Date(2025, 7, 28, 10, 30);
console.log(futureDate); // Thu Aug 28 2025 10:30:00 GMT+0200

// date.getFullYear()    returns year ( never use getYear()!! )
console.log(futureDate.getFullYear()); // 2025

// date.getMonth()    returns month
console.log(futureDate.getMonth()); // 7 (august is 7 ZERO BASED)

// date.getDate()    returns day of month
console.log(futureDate.getDate()); // 28

// date.getDay()    returns day of the week
console.log(futureDate.getDay()); // 4 (0 IS SUNDAY)

// date.getHours()    returns hours
console.log(futureDate.getHours()); // 10

// date.getMinutes()    returns mniutes
console.log(futureDate.getMinutes()); // 30

// date.getSeconds()    returns seconds
console.log(futureDate.getSeconds()); // 0

// date.getMilliseconds()    returns milliseconds
console.log(futureDate.getMilliseconds()); // 0

// date.toISOString()    returns ISO string (international standard)
// "Z" in the ends means "UTC": Coordinated Universal Time (time without any time zone in London and without daylight savings)
console.log(futureDate.toISOString()); // 2025-08-28T08:30:00.000Z

// date.getTime()    returns timestamp (milliseconds passed since January 1, 1970)
console.log(futureDate.getTime()); // 1756369800000

// Date.now()    retuns current timestamp (now exact moment)
console.log(Date.now()); // 1701012829399

// (!) NOTE: also there "set" version for previous methods
// EXAMPLE:
futureDate.setYear(2030);
console.log(futureDate); // Wed Aug 28 2030 10:30:00 GMT+0200






///////////////////////////
// Operations with dates //
///////////////////////////

// creating 2 dates and get only the timestamp (number data type)
const data1 = new Date(2023, 10, 25).getTime();
const data2 = new Date(2023, 10, 20).getTime();

// function which returns difference of days
const calcDaysPassed = (date1, date2) =>
  Math.round(Math.abs(date2 - date1) / (1000 * 60 * 60 * 24));

// testing function "calcDaysPassed"
console.log(calcDaysPassed(data1, data2)); // 5

// NOTE: 
// you can just use date library "moment.js" if you need precicly calculations on dates






/////////////////////////////////////
// Internationalizing dates (INTL) //
/////////////////////////////////////

// JS has a new Internationalization API called "INTL"
// It helps you to easily format numbers and strings according to different languages.

// So, INTL namespace object contains several constructors.
// One of the constuctor functions is Intl.DateTimeFormat() to work with dates

// Intl Docs:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl
// Intl.DateTimeFormat Docs:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat
// All options:               https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat

// SYNTAX:

// Intl.DateTimeFormat(localStr, options)                 --> returns formatter
// Intl.DateTimeFormat(localStr, options).format(date)    --> returns date in string formatted for the given country
//    `localStr` is the language-country (like `en-US`)
//    `options` is optional argument which expects a configuratiopn object with parameters

// You can get the `localStr` from user's browser:
const locale = navigator.language;
console.log(locale); // it-IT
// NOTE: also you can pass `undefined` in `localStr` to use the browser's default locale

// ----------------------- EXAMPLES ----------------------- //

const now = new Date();
console.log(now); // Tue Nov 28 2023 15:47:42 GMT+0100

const dateV0 = Intl.DateTimeFormat(`en-US`).format(now);
console.log(dateV0); // 11/28/2023 (USA format without options so with default configuration)

// -------------------------------------------------------- //

const options1 = {
  hour: `numeric`,
  minute: `numeric`,
};

const dateV1 = Intl.DateTimeFormat(`en-US`, options1).format(now);
console.log(dateV1); // 4:06 PM (shows only what is provided by options)

// -------------------------------------------------------- //

const options2 = {
  hour: `numeric`,
  minute: `numeric`,
  seconds: `numeric`,
  day: `numeric`,
  month: `long`,
  year: `numeric`,
  weekday: `long`,
};

const dateV2UK = Intl.DateTimeFormat(`en-UK`, options2).format(now);
console.log(dateV2UK); // Tuesday, 28 November 2023 at 16:13

const dateV2RU = Intl.DateTimeFormat(`ru-RU`, options2).format(now);
console.log(dateV2RU); // вторник, 28 ноября 2023 г. в 16:14

// -------------------------------------------------------- //






///////////////////////////////////////
// Internationalizing numbers (INTL) //
///////////////////////////////////////

// SYNTAX:    Intl.NumberFormat(localStr, options).format(yourNumber)
//    `localStr` is the language-country (like `en-US`)
//    `options` is optional argument which expects a configuratiopn object with parameters

// More:    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat

/*
OPTIONS ={
  style: "decimal/unit/percent/currency",
  unit: "mile-per-hour/kilometer-per-hour/celsius/liter....",
  unitDisplay: "long",
  currency: "EUR/JPY/",
  ALL OPTIONS:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
}
*/

// You can get the `localStr` from user's browser:
const locale = navigator.language;
console.log(locale); // it-IT
// NOTE: also you can pass `undefined` in `localStr` to use the browser's default locale

// ----------------------- EXAMPLES ----------------------- //

const randomNumber = 387403.23;

// -------------------------------------------------------- //

console.log(Intl.NumberFormat(`en-US`).format(randomNumber)); // 387,403.23
console.log(Intl.NumberFormat(`it-IT`).format(randomNumber)); // 387.403,23
console.log(Intl.NumberFormat(`ru-RU`).format(randomNumber)); // 387 403,23

// -------------------------------------------------------- //

const options1 = {
  style: `unit`,
  unit: `mile-per-hour`,
};

console.log(Intl.NumberFormat(`en-US`, options1).format(randomNumber)); // 387,403.23 mph
console.log(Intl.NumberFormat(`it-IT`, options1).format(randomNumber)); // 387.403,23 mi/h
console.log(Intl.NumberFormat(`ru-RU`, options1).format(randomNumber)); // 387 403,23 ми/ч

// -------------------------------------------------------- //

const options2 = {
  style: `unit`,
  unit: `celsius`,
};

console.log(Intl.NumberFormat(`en-US`, options2).format(randomNumber)); // 387,403.23°C
console.log(Intl.NumberFormat(`it-IT`, options2).format(randomNumber)); // 387.403,23 °C
console.log(Intl.NumberFormat(`ru-RU`, options2).format(randomNumber)); // 387 403,23 °C

// -------------------------------------------------------- //


___________________________________________________________________________

// universal function to display currency
const formatCurrency = function (value, locale, currency) {
  const options = {
    style: `currency`,
    currency: currency,
  };
  return Intl.NumberFormat(locale, options).format(value);
};
___________________________________________________________________________



// testing formatCurrency()
console.log(formatCurrency(34.23, `en-US`, `EUR`)); // €34.23






////////////////////////////////////////
// Timers: setTimeout and setInterval //
////////////////////////////////////////

// SYNTAX:        setTimeout(callback, msTime)
//                setTimeout(callback(Arg1, Arg2...), msTime, 0...)
// To cancel it:  if(condition) clearTimeout(setTimeoutName);

// setTimeout() runs once after the given time (msTime)
// Important: the code continues running without waiting for the given time (msTime)
// Optionally, pass arguments inside the callback function
// You can cancel the callback until the delay actually passes
// To cancel it, store setTimeout() inside a variable
// and pass that variable as an argument inside clearTimeout after your condition

// Simple example
setTimeout(() => console.log(`Hello`), 3 * 1000); // `Hello` (after 3 seconds)

// Example with 3 arguments
setTimeout(
  (arg1, arg2, arg3) => console.log(`Hello ${arg1}, ${arg2}, and ${arg3}`),
  3 * 1000,
  `John`,
  `Alex`,
  `Karl`
); // Hello John, Alex, and Karl

// Example of cancelling setTimeout()
const names = [`John`, `Alex`, `Karl`];
const callNames = setTimeout(
  (arg1, arg2, arg3) => console.log(`Hello ${arg1}, ${arg2}, and ${arg3}`),
  3 * 1000,
  ...names
);
if (names.includes(`Karl`)) {
  clearTimeout(callNames);
} // WILL NEVER RUN

// -------------------------------------------------------- //

// SYNTAX:        setInterval(callback, msTime)
//                setInterval(callback(Arg1, Arg2...), msTime, passInArg1, passInArg2...)
// To cancel it:  if(condition) clearInterval(setIntervalName);

// setInterval() executes the callback function forever after `msTime` until you stop it
// Important: the code continues running without waiting for the given time (msTime)
// Optionally, pass arguments inside the callback function
// You can also cancel the callback function
// To cancel it, store setInterval() inside a variable
// and pass that variable as an argument inside clearInterval after your condition

// Simple example
setInterval(() => console.log(`Hello world`), 5 * 1000); // `Hello world` (every 5 seconds)

// Example to console.log() the time after each second
setInterval(() => console.log(new Date().toISOString()), 1000); // 2023-11-28T21:33:30.743Z (every second)









___________________________________________________________________________________________________________________________________
09. ADVANCED DOM AND EVENTS






//////////////////////////////
// How the DOM really works //
//////////////////////////////

// DOM (Document Object Model) is basically interface between browser in JS code.
// DOM allows JS interact with browser
// So the code can modify HTML elements, styles, classes, attributes, listen and respond to events
// DOM tree is generated from HTML document
// DOM is a very complex API which containt a lot of methods and properties

// All methods and properties are organized in different types of nodes.
// Each node is represented in JavaScript by an object (which has methods and properties)
// `Node` -> every single node in DOM tree is of the type node.
//      - .textContent
//      - .childNodes
//      - .parentNode
//      - .cloneNode()    etc ...

// Types of child nodes:

// 1. Text        -> <p>paragraph</p>
// 2. Comment     -> <!--comment-->
// 3. Document    -> querySelector(), createElement(), getElementById() ...
// 4. Element     -> gives html element access to many methods and properties
//                    . innerHtml
//                    .classList
//                    .children
//                    .parentElement
//                    .append()
//                    .remove()
//                    .insertAdjacentHTML()
//                    .querySelector()
//                    .closest()
//                    .matches()
//                    .scrollIntoView()
//                    .setAttribute()
//                    etc....
// 4.1.   HTMLElement
// 4.1.1  HTMLButtonElement (for each HTML element that exists in HTML)
// 4.1.2  HTMLDivElement  (each of these children element has unique properties)
// 4.1.3  etc... images, ul, li ...

// Inheritance makes everything work;
// Inheritance: means all the child types will also get access to the methods and properties of all their parent node types.

// EventTarget -> special node which is PARENT of `Node` and `Window` nodes type
//                thanks to this node and inheritance you can call addEventListener to every single type of node.






///////////////////////////////////////////////
// Selecting, creating and deleting elements //
///////////////////////////////////////////////



// ------------------- SELECTING ELEMENTS ------------------- //



// selecting the entire document, head and body:

console.log(document.documentElement);
console.log(document.head);
console.log(document.body);

// :root === document.documentElement



// other methods of selecting:

document.querySelector(`.header`); // returns the 1st element which matches the selector
document.querySelectorAll(`.section`); // returns NodeList with all elements which matches the selector
document.getElementById(`section--1`); // returns the element which matches the id
document.getElementsByTagName(`buttons`); // returns an life HTML collection with all HTML elements with type of `buttons` in this case
document.getElementsByClassName(`btn`); // return a life html collection with all elements with class of `btn`

// NOTE: `HTML collection` is a `life-collection" which means they automatically updated when DOM changes
// NOTE: `NodeList` are not automatically updated



// ------------------- CREATING ELEMENTS ------------------- //



// 1. insertAdjacentHTML

// container.insertAdjacentHTML(`afterbegin`, htmlPiece);

// You can create a variable containing the template literal string with HTML.
// Then you can simply "inject" this template literal inside the HTML.

// htmlElement.insertAdjacentHTML(`place`, htmlString);
//  where `place` can be:
//      - "beforebegin"     -> before the html element if it has parent
//      - "afterbegin"      -> inside the html element before the 1st child
//      - "beforeend"       -> inside the html element after the last child
//      - "afterend"        -> after the html element if it has parent


// -------------- //


// 2. document.createElement(HtmlTagNameStr);

const message = document.createElement(`div`);

// this method also returns A DOM element
// this element is not yet in DOM but it's stored in a variable and you can do operations on it
// (the element retur is of the same type like element returned from document.querySelector(`.header`); )
message.classList.add(`cookie-message`);
message.textContent = `We're using cookies to improve functionality`;
message.innerHTML = `We're using cookies to improve functionality <button class="btn btn--close-cookie">Got it!</button>`;


// -------------- //


// 3. prepend() append() -> actually adding this elemento to the HTML

container.prepend(message); // add message as the first child of the container
container.append(message); // add message as the last child of the container

// now this message is life element of the DOM (it CAN'T be in different places in the document)
// so in the example above it was positioned as 1st child, then moved as last child
// so you can use prepand and append to move elements


// -------------- //


// 4. cloneNode() -> copy element

container.append(message.cloneNode(true)); // add message as the last child of the container
// if argument is `true` also the child elements will be copied


// -------------- //


// 5. before() after()

// before() insert element before HTML element (not as child)
// after() insert element after HTML element (not as child)
container.before(message);



// ------------------- DELETING ELEMENTS ------------------- //



// 1. remove() -> removes element from HTML (recent element)
message.remove();

// 2. elementXX.parentElement.removeChild(elementXX); (legacy)
// before we needed to select the parent element and then remove the children
message.parentElement.removeChild(message);





  // ----------------------------------------- //
EXAMPLE OF CREATING, ADDING AND REMOVING A COOKIE DIV:
  // ----------------------------------------- //


const header = document.querySelector(`.header`);

const cookieMessageDiv = document.createElement(`div`);
cookieMessageDiv.classList.add(`cookie-message`);
cookieMessageDiv.innerHTML = `I know cookies are so sad, but we're using them to improve functionality <button class="btn btn--close-cookie">Got it!</button>`;
header.before(cookieMessageDiv);

// selecting AFTER creating
const btnCloseCookie = document.querySelector(`.btn--close-cookie`);

// EventListener close Cookies Div
btnCloseCookie.addEventListener(`click`, function () {
  cookieMessageDiv.remove();
});






////////////////////////////////////
// Styles, attributes and classes //
////////////////////////////////////



// ------------------- STYLES ------------------- //


//    element.style.camelCaseStyle = `value`
// change style property
// doing this way the styles will be places `inline`
cookieMessageDiv.style.backgroundColor = `#37383d`;
cookieMessageDiv.style.width = `120%`;


//    element.style.camelCaseStyle
// read style property ONLY set inline
console.log(cookieMessageDiv.style.width); // 120%
console.log(cookieMessageDiv.style.height); // NOTHING BECAUSE IS NOT INLINE STYLE


//    getComputedStyle(element).camelCaseStyle
// get the real style as it appears on the page (even if it's not declared)
console.log(getComputedStyle(cookieMessageDiv)); // A REALLY BIG LIST OF STYLES
console.log(getComputedStyle(cookieMessageDiv).height); // 75px


//    document.documentElement.style.setProperty(`nameOfProperty`, `newValue`)
// css variables === (css custom properties)
// change the value of a css variable
document.documentElement.style.setProperty(`--color-primary`, `#52a064`);



// EXAMPLE:
cookieMessageDiv.style.height =
  Number.parseFloat(getComputedStyle(cookieMessageDiv).height) + 30 + `px`;




// ------------------- ATTRIBUTES ------------------- //


// attributes are: src, alt, id, href, placeholder etc...
// every type of element has its own standard attributes


//    element.standardAttributeName
// get or set the value of the standard attributes
console.log(logoIMG.src); // http://127.0.0.1:5500/img/logo.png (ABSOLUTE URL)
console.log(logoIMG.alt); // Bankist logo
console.log(logoIMG.className); // nav__logo (it's className and not simply class)

logoIMG.alt = `Cool Bankist App Logo`;
console.log(logoIMG.alt); // Cool Bankist App Logo


//    element.getAttribute(`attributeName`)
// get the value of the NON standard attributes (also works with standrd)
// this method gives you RELATIVE attibutes and not ABSOLUTE (of src, href...)
console.log(logoIMG.designer); // undefined (BECAUSE IT'S NOT STANDARD PROPERTY)
console.log(logoIMG.getAttribute(`designer`)); // Jonas
console.log(logoIMG.getAttribute(`src`)); // img/logo.png


//    element.setAttribute(`attributeName`, `newValue`)
// set the value of the NON standard attributes
logoIMG.setAttribute(`designer`, `Jonas New Attribute`);
console.log(logoIMG.getAttribute(`designer`)); // Jonas New Attribute


//    element.dataset.dataAttributeName = `newValue`
// get or set data attribute from `dataSet` object
// NOTE:  there is a special type of attributes called `data attributes`
//        data attributes always starts with `data-`
//        we need to transform the name in camelcase without 1st word `data` like below
//        example: data-version-number-actual="3.0"   --> versionNumberActual
console.log(logoIMG.dataset.versionNumberActual); // 3.0




// ------------------- CLASSES ------------------- //

// element.classList.add(`className`)
// element.classList.remove(`className`)
// element.classList.toggle(`className`)
// element.classList.contains(`className`)

// this OVVERERIDE all classes (bad practice)
// element.className = `className`






///////////////////////////////////
// Implementing Smooth scrolling //
///////////////////////////////////

---------------------------------------------------------------------------------

//    element.getBoundingClientRect();
// returns `DOMRect object` which is the smallest rectangle which contains the entire element
// this object describes the position and size of the overall rectangle in pixels
// Properties (NOT width and height) are relative to the top-left of the viewport.

EXAMPLE of DOMRect object:
  bottom: 3657.1875
  height: 2384.1875
  left: 0
  right: 641
  top: 1273
  width: 641
  x: 0                -> px from left of viewport
  y: 1273             -> px from top of viewport


---------------------------------------------------------------------------------

//    window.scroll(x, y)    /    window.scroll(optionsObject)
// scroll windows to coordinates of x and y (in pixels)
// scrollTo() is the same method

options = {
  top: 100,
  left: 100,
  behavior: "smooth" / "instant" / "auto",
}


console.log(window.scrollX); // returns px of scrolling from LEFT
console.log(window.scrollY); // returns px of scrolling from TOP


---------------------------------------------------------------------------------

//    calculate viewport size
document.documentElement.clientHeight; // returns px of the viewport height
document.documentElement.clientWidth; // returns px of the viewport width

---------------------------------------------------------------------------------


// PRACTICAL EXAMPLE:

// selecting elements
const btnScrollTo = document.querySelector(`.btn--scroll-to`);
const section1 = document.getElementById(`section--1`);



btnScrollTo.addEventListener(`click`, function (event) {
  // get the coordinates of seciton1
  const seciton1Coordinates = section1.getBoundingClientRect();

  // to get the correct coordinates you need to sum:
  //  1. px from top of viewport
  //  2. current scroll position
  // like this:
  const sect1X = seciton1Coordinates.x + window.scrollX;
  const sect1Y = seciton1Coordinates.y + window.scrollY;

  // creating the object with options for scroll()
  const scrollOptions = {
    top: sect1Y,
    left: sect1X,
    behavior: `smooth`,
  };

  // scroll to the correct position
  window.scroll(scrollOptions);
});


---------------------------------------------------------------------------------
// MODERN WAY:
// element.scrollIntoView({behavior: `smooth`});
section1.scrollIntoView({ behavior: `smooth` })
---------------------------------------------------------------------------------






////////////////////////////////////////
// Types of events and event handlers //
////////////////////////////////////////

// Events:
// an event is a signal generated by a certain dumb node, so when something happens.

// There are 3 main methods to add event listeners:

//  1.  using on-event propery directly on the element
//      element.onmouseenter = function() {...};
//      this is the old way of attaching events

//  2.  add event in HTML like: onclick="alert(`hello`)"
//      never use this

//  3.  element.addEventListener(`mouseenter`, function() {...})
//      it allows to add multiple event listeners to the same event.
//      also it allows you to remove an event listener
//      element.removeEventListener(`eventType`, functionId)
//      you can remove it in setTimeout() or, for example, in the end of the callback to execute is once

// EXAMPLE:
const h1 = document.querySelector(`h1`);

const alertH1 = function (e) {
  alert(`Hello! Mouse is hovered...`);

  // remove event listener in the end
  h1.removeEventListener(`mouseenter`, alertH1);
};

// mouseenter is like :hover in css
h1.addEventListener(`mouseenter`, alertH1);






///////////////////////////////////////////////
// Event propagation: bubbling and capturing //
///////////////////////////////////////////////

// JS have important property: capturing phase and a bubbling phase.
// For example if you click on anchor link an event happens,
// but, usually, the event is not generated on the anchor link element, but in the root document.

// The way of event:
//  1.  Most of events are generated in the root element
//  2.  Capturing phase: event then travels all the way down from the document route to the target element.
//      Event is passing through every single parent element.
//  3.  Target pahes: when event reach the target and can be handled right at the target.
//      We're handling the events with event listeners and attach there callback function
//  4.  Bubbling phase: event then travels all the way up to the document route again
//      the event passes through all its parent elements againg (not any sibling elements)

// (!)
// Bubbling is important because if you attach the same event listener, also for example,
// to the parent element, then you would get the exact same result (callback)
// so you would have handled the exact same event twice

// Note: not all type of event do Capturing and Bubbling (but almost any)







/////////////////////////////////
// Event propagation: practice //
/////////////////////////////////


// Now if you click on child element (<a>) also both parent elements'll change background color
// This happens because parent elements handles the event listener also on children (during bubbling)


// IMPORTANT:
// `event.target`         --> is element where events happens and not the element where event listener is attached
// `event.currentTarget`  --> is element on which is attached the event listener and not element where event happens
// so: event.currentTarget === `this` keyword


// You can stop the event propagation (parent elements don't handel event of children)
// event.stopPropagation();


// You can catch events during the Capturing and not Bubbling (default)
// To do that you need to set the 3rd parameter of addEventListener() to true
// element.addEventListener(`event`, callback, boolean)
// so if  `true`: the event handler will no longer listen to bubbling events but instead, to capturing events.
// if `false` default the event handler will listen during bubbling
// NOT really usuful in modern days



EXAMPLE:
---------------------------------------------------------------------------------
// function which creates a random number between MIN and MAX
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1)) + min;

// 3 event listeners on <a>, <li> and <nav> (where last is parent) to change color on random on click
document.querySelector(`.nav__link`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);

  // stop event propagation
  e.stopPropagation();
});

document.querySelector(`.nav__links`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});

document.querySelector(`.nav`).addEventListener(`click`, function (e) {
  const randomColor = `rgb(${randomInt(0, 255)},${randomInt(
    0,
    255
  )},${randomInt(0, 255)})`;
  this.style.backgroundColor = randomColor;
  console.log(`target:`, e.target);
  console.log(`currentTarget:`, e.currentTarget);
});
---------------------------------------------------------------------------------







////////////////////////////////////////////////////
// Event delegation: implementing page navigation //
////////////////////////////////////////////////////



---------------------------------------------------------------------------------
NOT EFFICIENT WAY:

// this works fine but it's not efficient
// because I added the exact same callback function 3 times (unnecessary)
// if I have 1000 elements it's gonna affect the performance by copiing the callback 1000 times...



// get the nodeList of all `.nav__link` and attach event listener to all of them
document.querySelectorAll(`.nav__link`).forEach(function (element) {
  element.addEventListener(`click`, function (event) {
    // prevent default behavior for all events (moving to href="#id")
    event.preventDefault();

    // get the href attribute of the current element
    const id = element.getAttribute(`href`); // example output: "#section--3"

    // so onclick scrollIntoView to that id
    document.querySelector(id).scrollIntoView({ behavior: `smooth` });
  });
});

---------------------------------------------------------------------------------
EFFICIENT WAY USING EVENT DELEGATION:

// The better solution is to use event delegation
// so we use the fact that event is bubbled up
// so we need to attach event listener to the common parent (container) of all interested elements.


//  add event listener to common parent (container) of all interested elements.
document
  .querySelector(`.nav__links`)
  .addEventListener(`click`, function (event) {
    // prevent default behavior
    event.preventDefault();

    // determine what element originated the event
    const eventElement = event.target;

    // check if eventElement is actually interested element (.nav__link)
    if (eventElement.classList.contains(`nav__link`)) {

      // if it's interested element get the href attribute of the element and store it in "idHref"
      const idHref = eventElement.getAttribute(`href`);

      // then scroll to that id "idHref"
      document.querySelector(idHref).scrollIntoView({ behavior: `smooth` });
    }
  });
---------------------------------------------------------------------------------







////////////////////
// DOM traversing //
////////////////////


// Traversing = you can select an element based on another element.
//              (like direct child or a direct parent element)
// indeed you can also set this properties or set, for example, their style (not only read)



const h1 = document.querySelector(`h1`);



// ------------------- CHILDREN ------------------- //



//    element.querySelectorAll(`...`)
// return Nodelist with CHILDREN elements and doesn't matter how deep they are
console.log(h1.querySelectorAll(`.highlight`));

//    element.childNodes
// return NodeList with all direct children
console.log(h1.childNodes);

//    element.children
// return HTMLCollection (live collection) with all direct children real elements (for example no comments)
console.log(h1.children);

//    element.firstElementChild
// return first element child of HTMLCollection
console.log(h1.firstElementChild);
h1.firstElementChild.style.color = `white`; // example of setting style

//    element.lastElementChild
// return last element child of HTMLCollection
console.log(h1.lastElementChild);



// ------------------- PARENTS ------------------- //



//    element.parentNode
// return the Nodelist/element direct parent
console.log(h1.parentNode);

//    element.parentElement
// return the direct parent (usually use this)
console.log(h1.parentElement);

//    element.closest(`.container/#section1/h1`)
// return Nodelist/element with PARENTS elements and doesn't matter how deep (up) they are
console.log(h1.closest(`header`));
console.log(h1.closest(`h1`)); // return the same element



// ------------------- SIBLINGS ------------------- //



//    element.previousElementSibling
// return the previous direct sibling
console.log(h1.previousElementSibling);

//    element.nextElementSibling
// return the next direct sibling
console.log(h1.nextElementSibling);

//    element.previousElementSibling
// return the NodeList with previous direct sibling
console.log(h1.previousSibling);

//    element.nextElementSibling
// return the NodeList with next direct sibling
console.log(h1.nextSibling);

//    element.parentElement.children
// return the HTMLCollection with all siblings (element inclusive)
console.log(h1.parentElement.children);

// do something with all siblings but not element itself
[...h1.parentElement.children].forEach(function (element) {
  if (element !== h1) {
    console.log(`Do something here with siblings`);
  }
});







/////////////////////////////////
// Building a tabbed component //
/////////////////////////////////

// selecting elements to work with tabs
const tabsContainer = document.querySelector(`.operations__tab-container`);
const tabsBtns = document.querySelectorAll(`.operations__tab`);
const tabsContents = document.querySelectorAll(`.operations__content`);

// using event delegation, so add event listener on container
tabsContainer.addEventListener(`click`, function (event) {
  // preventing default just to be sure (not really necessary)
  event.preventDefault();

  // get the element (during bubbling) which provocated event --> event.target
  // and find the actual button because there is the <span> inside --> .closest(`.operations__tab`);
  const clickedBtn = event.target.closest(`.operations__tab`);

  // if `clickedBtn` is null so there was a click on container and not button then just exit function
  if (!clickedBtn) return;

  // otherwise get the `data-tab` attribute to understand which content should be shown
  const numberContent = clickedBtn.dataset.tab;

  // remove active class from all tab buttons
  // and add active class only on clicked tab button
  tabsBtns.forEach(el => el.classList.remove(`operations__tab--active`));
  clickedBtn.classList.add(`operations__tab--active`);

  // remove active class from all <div>s with content to show
  // and add active class only to <div> with correct numberContent class
  tabsContents.forEach(el =>
    el.classList.remove(`operations__content--active`)
  );
  document
    .querySelector(`.operations__content--${numberContent}`)
    .classList.add(`operations__content--active`);
});







/////////////////////////////////////////
// Passing arguments to event handlers //
/////////////////////////////////////////


// NOTE:
//  `mouseover` and `mouseout` do bubbling
//  `mouseenter` and `mouseleave` don't do bubbling


const changeOpacityNav = function (event, opacity) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = opacity;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = opacity;
  }
};

const navBar = document.querySelector(`.nav`);

navBar.addEventListener(`mouseover`, function (event) {
  changeOpacityNav(event, 0.5);
});

navBar.addEventListener(`mouseout`, function (event) {
  changeOpacityNav(event, 1);
});




//// --------------- BEST SOLUTION --------------- ////




// The best way to pass argument into an event handlers' callback function
// is to use bind method, set the `this` keyword and pass `this` as variable inside the callback body
// any event handler function can have only 1 real argument, which is the `event`
// if you want to pass more arguments set `this` in bind to an array or object

const navBar = document.querySelector(`.nav`);

const changeOpacityNav = function (event) {
  // get the element provocated the event
  const provocatorEvent = event.target;

  // check if `provocatorEvent` is actual <a> so with class "nav__link"
  if (provocatorEvent.classList.contains(`nav__link`)) {
    // get all the siblings of `provocatorEvent`
    const siblingsProvocator = provocatorEvent
      .closest(`.nav`)
      .querySelectorAll(`.nav__link`);

    // get also logo image
    const imageNav = provocatorEvent.closest(`.nav`).querySelector(`img`);

    // change the opacity of all `siblingsProvocator` but not of the `provocatorEvent`
    siblingsProvocator.forEach(sibling => {
      if (sibling !== provocatorEvent) sibling.style.opacity = this;
    });

    // change also the opacity of logo image
    imageNav.style.opacity = this;
  }
};

navBar.addEventListener(`mouseover`, changeOpacityNav.bind(0.5));
navBar.addEventListener(`mouseout`, changeOpacityNav.bind(1));







////////////////////////////////////////////////////////
// Implementing a sticky navigation: the scroll event //
////////////////////////////////////////////////////////



//// -------------- OLD BAD SOLUTION -------------- ////



// REMEMBER:
// const navBar = document.querySelector(`.nav`);
// const section1 = document.getElementById(`section--1`);

// calculate the coordinates of section1
const seciton1Coordinates = section1.getBoundingClientRect();

window.addEventListener(`scroll`, function () {
  if (window.scrollY > seciton1Coordinates.top) {
    navBar.classList.add(`sticky`);
  } else {
    navBar.classList.remove(`sticky`);
  }
});







///////////////////////////////////
// The intersection Observer API //
///////////////////////////////////

